# DP: updates from the gcc-10 branch upto 20230110 (e3e673dd183).

LANG=C git diff --no-renames --src-prefix=a/src/ --dst-prefix=b/src/ \
	7ff47281ce4f3699185b06a3430968eac2a5b0c6 e3e673dd18327ef86af94ba0e1a341f904898134 \
	| awk '/^diff .*\.texi/ {skip=1; next} /^diff / { skip=0 } skip==0' \
	| grep -v -E '^(diff|index)'

--- a/src/gcc/ChangeLog
+++ b/src/gcc/ChangeLog
@@ -1,3 +1,376 @@
+2023-01-05  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106736
+	* config/rs6000/mma.md (define_expand movoo): Call function
+	rs6000_opaque_type_invalid_use_p to check and emit error message for
+	the invalid use of opaque type.
+	(define_expand movxo): Likewise.
+	* config/rs6000/rs6000-protos.h
+	(rs6000_opaque_type_invalid_use_p): New function declaration.
+	(currently_expanding_gimple_stmt): New extern declaration.
+	* config/rs6000/rs6000.c (rs6000_opaque_type_invalid_use_p): New
+	function.
+
+2022-12-22  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-08-10  Martin Liska  <mliska@suse.cz>
+
+	* opts-jobserver.h: Add one member.
+	* opts-common.c (jobserver_info::jobserver_info): Parse FIFO
+	format of --jobserver-auth.
+
+2022-12-22  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-08-10  Martin Liska  <mliska@suse.cz>
+
+	* gcc.c (driver::detect_jobserver): Remove and move to
+	jobserver.h.
+	* lto-wrapper.c (jobserver_active_p): Likewise.
+	(run_gcc): Likewise.
+	* opts-jobserver.h: New file.
+	* opts-common.c (jobserver_info::jobserver_info): New function.
+
+2022-12-15  Sebastian Pop  <spop@amazon.com>
+
+	PR target/98776
+	* config/aarch64/aarch64-protos.h (aarch64_output_patchable_area):
+	Declared.
+	* config/aarch64/aarch64.c (aarch64_print_patchable_function_entry):
+	Emit an UNSPECV_PATCHABLE_AREA pseudo instruction.
+	(aarch64_output_patchable_area): New.
+	* config/aarch64/aarch64.md (UNSPECV_PATCHABLE_AREA): New.
+	(patchable_area): Define.
+
+2022-12-01  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/107863
+	* config/i386/i386-expand.c (ix86_expand_vec_set_builtin):
+	Convert op1 to target mode whenever mode mismatch.
+
+2022-11-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (addvdi3): Force operand 2 to a register.
+	Remove "addi,tsv,*" instruction from unamed pattern.
+	(subvdi3): Force operand 1 to a register.
+	Remove "subi,tsv" instruction from from unamed pattern.
+
+2022-11-29  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backported from master:
+	2022-11-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR rtl-optimization/107482
+	* ira-color.c (assign_hard_reg): Only call
+	update_costs_from_copies when retry_p is false.
+
+2022-11-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2022-11-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/nvptx/nvptx.h (STARTFILE_SPEC): Fix 'crt0.o' for
+	'-mmainkernel'.
+
+2022-11-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107485
+	* tree-inline.c (remap_gimple_stmt): Use correct type for
+	split out condition of [VEC_]COND_EXPRs.
+
+2022-11-08  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-10-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107304
+	* expr.c (get_inner_reference): Always use TYPE_MODE for vector
+	field with vector raw mode.
+
+2022-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c/41041
+	* doc/cppopts.texi: Document -fwide-exec-charset defaults
+	correctly.
+
+2022-10-25  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2022-10-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	PR target/106355
+	* config/s390/s390.c (s390_call_saved_register_used): For a
+	parameter with BLKmode fix determining number of consecutive
+	registers.
+
+2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-10-24  Martin Liska  <mliska@suse.cz>
+
+	PR target/107364
+	* common/config/i386/i386-cpuinfo.h (enum processor_vendor):
+	  Reorder enum values as BUILTIN_VENDOR_MAX should not point
+	  in the middle of the valid enum values.
+
+2022-10-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/107336
+	* optabs.c (expand_vec_cond_expr): Query both VCOND and VCONDU for
+	EQ and NE.
+
+2022-10-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64-sve.md (*aarch64_brk<brk_op>_cc): Remove
+	merging alternative.
+	(*aarch64_brk<brk_op>_ptest): Likewise.
+
+2022-10-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/iterators.md (SVE_BRKP): New iterator.
+	* config/aarch64/aarch64-sve.md (*aarch64_brkn_cc): New pattern.
+	(*aarch64_brkn_ptest): Likewise.
+	(*aarch64_brk<brk_op>_cc): Restrict to SVE_BRKP.
+	(*aarch64_brk<brk_op>_ptest): Likewise.
+
+2022-10-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (AARCH64_FL_FOR_ARCH8_3): Add
+	AARCH64_FL_RCPC.
+	(AARCH64_ISA_RCPC): New macro.
+	* config/aarch64/aarch64-cores.def (thunderx3t110, zeus, neoverse-v1)
+	(neoverse-512tvb, saphira): Remove RCPC from these Armv8.3-A+ cores.
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define
+	__ARM_FEATURE_RCPC when appropriate.
+
+2022-10-20  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96072
+	* config/rs6000/rs6000-logue.c (rs6000_emit_epilogue): Update the
+	condition for adding REG_CFA_DEF_CFA reg note with
+	frame_pointer_needed_indeed.
+
+2022-10-17  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	PR target/99685
+	* config/rs6000/rs6000-call.c (rs6000_function_arg_advance_1): Bump
+	register count when not splitting IEEE 128-bit Complex.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR lto/106540
+	PR lto/106334
+	* lto-streamer-in.c (lto_read_tree_1): Use lto_input_tree_1
+	to input DECL_INITIAL, avoiding to commit drefs.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106513
+	* gimple-ssa-store-merging.c (do_shift_rotate): Use uint64_t
+	for head_marker.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/106331
+	* builtins.c (get_memory_rtx): Compute alignment from
+	the original address and set MEM_OFFSET to unknown when
+	we create a MEM_EXPR from the base object of the address.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106131
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Force alias-set
+	zero when offsetting the read looking through an aggregate
+	copy.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-06-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106112
+	* tree-ssa-sccvn.c (valueized_wider_op): Properly extend
+	a constant operand according to its type.
+
+2022-10-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/107248
+	* config/sparc/sparc.c (sparc_expand_prologue): Emit a frame
+	blockage for leaf functions.
+	(sparc_flat_expand_prologue): Emit frame instead of full blockage.
+	(sparc_expand_epilogue): Emit a frame blockage for leaf functions.
+	(sparc_flat_expand_epilogue): Emit frame instead of full blockage.
+
+2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	PR target/107064
+	* config/i386/t-i386: Add build-time dependencies against
+	i386-builtin-types.inc to i386-builtins.o, i386-expand.o,
+	i386-features.o.
+
+2022-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-cores.def (neoverse-v2): New entry.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* doc/invoke.texi (AArch64 Options): Document neoverse-v2.
+
+2022-09-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-09-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/106491
+	* config/aarch64/aarch64-sve-builtins.cc (scalar_types)
+	(acle_vector_types, acle_svpattern, acle_svprfop): Add GTY
+	markup to (new) extern declarations instead of to the main
+	definition.
+
+2022-09-14  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2022-02-01  Tom de Vries  <tdevries@suse.de>
+
+	* config/nvptx/nvptx.c (nvptx_single): Use nvptx_uniform_warp_check.
+	* config/nvptx/nvptx.md (define_c_enum "unspecv"): Add
+	UNSPECV_UNIFORM_WARP_CHECK.
+	(define_insn "nvptx_uniform_warp_check"): New define_insn.
+
+2022-09-14  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2022-02-01  Tom de Vries  <tdevries@suse.de>
+
+	* config/nvptx/nvptx.c (nvptx_single): Use nvptx_warpsync.
+	* config/nvptx/nvptx.md (define_c_enum "unspecv"): Add
+	UNSPECV_WARPSYNC.
+	(define_insn "nvptx_warpsync"): New define_insn.
+
+2022-09-14  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/nvptx/nvptx.h (TARGET_PTX_6_0): '#define' to 'false'.
+
+2022-09-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* config/rs6000/rs6000-call.c (rs6000_gimple_fold_mma_builtin):
+	Enforce the use of a valid MMA pointer type.
+
+2022-09-08  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPP_OS_DEFAULT_SPEC): Define __PPC_VRSAVE__ if
+	-mvrsave is present.
+	* config/rs6000/t-rtems: Add -mvrsave multilib variants for
+	-mcpu=e6500.
+
+2022-08-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* config/rs6000/rs6000.c (rs6000_invalid_conversion): Remove handling
+	of MMA pointer conversions.
+
+2022-08-24  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-08-16  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/103353
+	* config/rs6000/mma.md (define_expand movpoi): Move TARGET_MMA condition
+	check to preparation statements and add handlings for !TARGET_MMA.
+	(define_expand movpxi): Likewise.
+
+2022-08-16  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/103197
+	PR target/102146
+	* config/rs6000/rs6000.md (zero_extendqi<mode>2 for EXTQI): Disparage
+	the "Z" alternatives in {l,st}{f,xs}iwzx.
+	(zero_extendhi<mode>2 for EXTHI): Ditto.
+	(zero_extendsi<mode>2 for EXTSI): Ditto.
+	(*movsi_internal1): Ditto.
+	(*mov<mode>_internal1 for QHI): Ditto.
+	(movsd_hardfloat): Ditto.
+
+2022-08-02  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-25  Peter Bergner  <bergner@linux.ibm.com>
+		    Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* config/rs6000/rs6000.h (DRIVER_SELF_SPECS): Adjust -mdejagnu-cpu
+	to filter out all -mtune options.
+
+2022-08-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106091
+	* config/rs6000/rs6000-p8swap.c (replace_swapped_aligned_store): Copy
+	REG_EH_REGION when replacing one store insn having it.
+	(replace_swapped_aligned_load): Likewise.
+
+2022-07-25  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backported from master:
+	2022-07-25  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPLUSPLUS_CPP_SPEC): Undef.
+
+2022-07-22  Surya Kumari Jangala  <jskumari@linux.vnet.ibm.com>
+
+	Backported from master:
+	2022-06-14  Surya Kumari Jangala  <jskumari@linux.ibm.com>
+
+	PR rtl-optimization/105041
+	* regrename.c (check_new_reg_p): Use nregs value from du chain.
+
+2022-07-13  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/105860
+	* tree-sra.c (build_reconstructed_reference): Start expr
+	traversal only just below the outermost union.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/gcc/DATESTAMP
+++ b/src/gcc/DATESTAMP
@@ -1 +1 @@
-20220628
+20230110
--- a/src/gcc/builtins.c
+++ b/src/gcc/builtins.c
@@ -1471,7 +1471,7 @@ expand_builtin_prefetch (tree exp)
 static rtx
 get_memory_rtx (tree exp, tree len)
 {
-  tree orig_exp = exp;
+  tree orig_exp = exp, base;
   rtx addr, mem;
 
   /* When EXP is not resolved SAVE_EXPR, MEM_ATTRS can be still derived
@@ -1502,10 +1502,11 @@ get_memory_rtx (tree exp, tree len)
   if (is_gimple_mem_ref_addr (TREE_OPERAND (exp, 0)))
     set_mem_attributes (mem, exp, 0);
   else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR
-	   && (exp = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),
-						     0))))
+	   && (base = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),
+						      0))))
     {
-      exp = build_fold_addr_expr (exp);
+      unsigned int align = get_pointer_alignment (TREE_OPERAND (exp, 0));
+      exp = build_fold_addr_expr (base);
       exp = fold_build2 (MEM_REF,
 			 build_array_type (char_type_node,
 					   build_range_type (sizetype,
@@ -1513,6 +1514,10 @@ get_memory_rtx (tree exp, tree len)
 							     NULL)),
 			 exp, build_int_cst (ptr_type_node, 0));
       set_mem_attributes (mem, exp, 0);
+      /* Since we stripped parts make sure the offset is unknown and the
+	 alignment is computed from the original address.  */
+      clear_mem_offset (mem);
+      set_mem_align (mem, align);
     }
   set_mem_alias_set (mem, 0);
   return mem;
--- a/src/gcc/c/ChangeLog
+++ b/src/gcc/c/ChangeLog
@@ -1,3 +1,12 @@
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* c-parser.c (c_parser_pragma): Set input_location to the
+	location of the pragma, rather than the start of the line.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/gcc/c/c-parser.c
+++ b/src/gcc/c/c-parser.c
@@ -12328,6 +12328,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)
   unsigned int id;
   const char *construct = NULL;
 
+  input_location = c_parser_peek_token (parser)->location;
   id = c_parser_peek_token (parser)->pragma_kind;
   gcc_assert (id != PRAGMA_NONE);
 
--- a/src/gcc/common/config/i386/i386-cpuinfo.h
+++ b/src/gcc/common/config/i386/i386-cpuinfo.h
@@ -30,8 +30,10 @@ enum processor_vendor
   VENDOR_INTEL = 1,
   VENDOR_AMD,
   VENDOR_OTHER,
-  BUILTIN_VENDOR_MAX = VENDOR_OTHER,
-  VENDOR_MAX
+
+  /* Maximum values must be at the end of this enum.  */
+  VENDOR_MAX,
+  BUILTIN_VENDOR_MAX = VENDOR_OTHER
 };
 
 /* Any new types or subtypes have to be inserted at the end. */
--- a/src/gcc/config/aarch64/aarch64-c.c
+++ b/src/gcc/config/aarch64/aarch64-c.c
@@ -199,6 +199,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)
 			"__ARM_FEATURE_BF16_VECTOR_ARITHMETIC", pfile);
   aarch64_def_or_undef (TARGET_BF16_FP,
 			"__ARM_FEATURE_BF16_SCALAR_ARITHMETIC", pfile);
+  aarch64_def_or_undef (AARCH64_ISA_RCPC, "__ARM_FEATURE_RCPC", pfile);
 
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
--- a/src/gcc/config/aarch64/aarch64-cores.def
+++ b/src/gcc/config/aarch64/aarch64-cores.def
@@ -128,20 +128,21 @@ AARCH64_CORE("tsv110",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_
 /* ARMv8.3-A Architecture Processors.  */
 
 /* Marvell cores (TX3). */
-AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)
+AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)
 
 /* ARMv8.4-A Architecture Processors.  */
 
 /* Arm ('A') cores.  */
-AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
-AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
-AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, INVALID_IMP, INVALID_CORE, -1)
+AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, INVALID_IMP, INVALID_CORE, -1)
 
 /* Qualcomm ('Q') cores. */
-AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
+AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO, saphira,   0x51, 0xC01, -1)
 
 /* Armv8.5-A Architecture Processors.  */
 AARCH64_CORE("neoverse-n2", neoversen2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoversen2, 0x41, 0xd49, -1)
+AARCH64_CORE("neoverse-v2", neoversev2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoversev1, 0x41, 0xd4f, -1)
 
 /* ARMv8-A big.LITTLE implementations.  */
 
--- a/src/gcc/config/aarch64/aarch64-protos.h
+++ b/src/gcc/config/aarch64/aarch64-protos.h
@@ -805,4 +805,6 @@ const char *aarch64_indirect_call_asm (rtx);
 extern bool aarch64_harden_sls_retbr_p (void);
 extern bool aarch64_harden_sls_blr_p (void);
 
+extern void aarch64_output_patchable_area (unsigned int, bool);
+
 #endif /* GCC_AARCH64_PROTOS_H */
--- a/src/gcc/config/aarch64/aarch64-sve-builtins.cc
+++ b/src/gcc/config/aarch64/aarch64-sve-builtins.cc
@@ -530,7 +530,8 @@ static CONSTEXPR const function_group_info function_groups[] = {
 };
 
 /* The scalar type associated with each vector type.  */
-GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+extern GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+tree scalar_types[NUM_VECTOR_TYPES];
 
 /* The single-predicate and single-vector types, with their built-in
    "__SV..._t" name.  Allow an index of NUM_VECTOR_TYPES, which always
@@ -538,13 +539,16 @@ GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
 static GTY(()) tree abi_vector_types[NUM_VECTOR_TYPES + 1];
 
 /* Same, but with the arm_sve.h "sv..._t" name.  */
-GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+extern GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
 
 /* The svpattern enum type.  */
-GTY(()) tree acle_svpattern;
+extern GTY(()) tree acle_svpattern;
+tree acle_svpattern;
 
 /* The svprfop enum type.  */
-GTY(()) tree acle_svprfop;
+extern GTY(()) tree acle_svprfop;
+tree acle_svprfop;
 
 /* The list of all registered function decls, indexed by code.  */
 static GTY(()) vec<registered_function *, va_gc> *registered_functions;
--- a/src/gcc/config/aarch64/aarch64-sve.md
+++ b/src/gcc/config/aarch64/aarch64-sve.md
@@ -9228,45 +9228,41 @@ (define_insn "@aarch64_brk<brk_op>"
 (define_insn "*aarch64_brk<brk_op>_cc"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
-	  [(match_operand:VNx16BI 1 "register_operand" "Upa, Upa")
+	  [(match_operand:VNx16BI 1 "register_operand" "Upa")
 	   (match_dup 1)
 	   (match_operand:SI 4 "aarch64_sve_ptrue_flag")
 	   (unspec:VNx16BI
 	     [(match_dup 1)
-	      (match_operand:VNx16BI 2 "register_operand" "Upa, Upa")
-	      (match_operand:VNx16BI 3 "aarch64_simd_reg_or_zero" "Dz, 0")]
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "aarch64_simd_imm_zero")]
 	     SVE_BRK_UNARY)]
 	  UNSPEC_PTEST))
-   (set (match_operand:VNx16BI 0 "register_operand" "=Upa, Upa")
+   (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
 	(unspec:VNx16BI
 	  [(match_dup 1)
 	   (match_dup 2)
 	   (match_dup 3)]
 	  SVE_BRK_UNARY))]
   "TARGET_SVE"
-  "@
-   brk<brk_op>s\t%0.b, %1/z, %2.b
-   brk<brk_op>s\t%0.b, %1/m, %2.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b"
 )
 
 ;; Same, but with only the flags result being interesting.
 (define_insn "*aarch64_brk<brk_op>_ptest"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
-	  [(match_operand:VNx16BI 1 "register_operand" "Upa, Upa")
+	  [(match_operand:VNx16BI 1 "register_operand" "Upa")
 	   (match_dup 1)
 	   (match_operand:SI 4 "aarch64_sve_ptrue_flag")
 	   (unspec:VNx16BI
 	     [(match_dup 1)
-	      (match_operand:VNx16BI 2 "register_operand" "Upa, Upa")
-	      (match_operand:VNx16BI 3 "aarch64_simd_reg_or_zero" "Dz, 0")]
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "aarch64_simd_imm_zero")]
 	     SVE_BRK_UNARY)]
 	  UNSPEC_PTEST))
-   (clobber (match_scratch:VNx16BI 0 "=Upa, Upa"))]
+   (clobber (match_scratch:VNx16BI 0 "=Upa"))]
   "TARGET_SVE"
-  "@
-   brk<brk_op>s\t%0.b, %1/z, %2.b
-   brk<brk_op>s\t%0.b, %1/m, %2.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b"
 )
 
 ;; -------------------------------------------------------------------------
@@ -9293,7 +9289,61 @@ (define_insn "@aarch64_brk<brk_op>"
   "brk<brk_op>\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
 )
 
-;; Same, but also producing a flags result.
+;; BRKN, producing both a predicate and a flags result.  Unlike other
+;; flag-setting instructions, these flags are always set wrt a ptrue.
+(define_insn_and_rewrite "*aarch64_brkn_cc"
+  [(set (reg:CC_NZC CC_REGNUM)
+	(unspec:CC_NZC
+	  [(match_operand:VNx16BI 4)
+	   (match_operand:VNx16BI 5)
+	   (const_int SVE_KNOWN_PTRUE)
+	   (unspec:VNx16BI
+	     [(match_operand:VNx16BI 1 "register_operand" "Upa")
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "register_operand" "0")]
+	     UNSPEC_BRKN)]
+	  UNSPEC_PTEST))
+   (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
+	(unspec:VNx16BI
+	  [(match_dup 1)
+	   (match_dup 2)
+	   (match_dup 3)]
+	  UNSPEC_BRKN))]
+  "TARGET_SVE"
+  "brkns\t%0.b, %1/z, %2.b, %0.b"
+  "&& (operands[4] != CONST0_RTX (VNx16BImode)
+       || operands[5] != CONST0_RTX (VNx16BImode))"
+  {
+    operands[4] = CONST0_RTX (VNx16BImode);
+    operands[5] = CONST0_RTX (VNx16BImode);
+  }
+)
+
+;; Same, but with only the flags result being interesting.
+(define_insn_and_rewrite "*aarch64_brkn_ptest"
+  [(set (reg:CC_NZC CC_REGNUM)
+	(unspec:CC_NZC
+	  [(match_operand:VNx16BI 4)
+	   (match_operand:VNx16BI 5)
+	   (const_int SVE_KNOWN_PTRUE)
+	   (unspec:VNx16BI
+	     [(match_operand:VNx16BI 1 "register_operand" "Upa")
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "register_operand" "0")]
+	     UNSPEC_BRKN)]
+	  UNSPEC_PTEST))
+   (clobber (match_scratch:VNx16BI 0 "=Upa"))]
+  "TARGET_SVE"
+  "brkns\t%0.b, %1/z, %2.b, %0.b"
+  "&& (operands[4] != CONST0_RTX (VNx16BImode)
+       || operands[5] != CONST0_RTX (VNx16BImode))"
+  {
+    operands[4] = CONST0_RTX (VNx16BImode);
+    operands[5] = CONST0_RTX (VNx16BImode);
+  }
+)
+
+;; BRKPA and BRKPB, producing both a predicate and a flags result.
 (define_insn "*aarch64_brk<brk_op>_cc"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
@@ -9303,17 +9353,17 @@ (define_insn "*aarch64_brk<brk_op>_cc"
 	   (unspec:VNx16BI
 	     [(match_dup 1)
 	      (match_operand:VNx16BI 2 "register_operand" "Upa")
-	      (match_operand:VNx16BI 3 "register_operand" "<brk_reg_con>")]
-	     SVE_BRK_BINARY)]
+	      (match_operand:VNx16BI 3 "register_operand" "Upa")]
+	     SVE_BRKP)]
 	  UNSPEC_PTEST))
    (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
 	(unspec:VNx16BI
 	  [(match_dup 1)
 	   (match_dup 2)
 	   (match_dup 3)]
-	  SVE_BRK_BINARY))]
+	  SVE_BRKP))]
   "TARGET_SVE"
-  "brk<brk_op>s\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b, %3.b"
 )
 
 ;; Same, but with only the flags result being interesting.
@@ -9326,12 +9376,12 @@ (define_insn "*aarch64_brk<brk_op>_ptest"
 	   (unspec:VNx16BI
 	     [(match_dup 1)
 	      (match_operand:VNx16BI 2 "register_operand" "Upa")
-	      (match_operand:VNx16BI 3 "register_operand" "<brk_reg_con>")]
-	     SVE_BRK_BINARY)]
+	      (match_operand:VNx16BI 3 "register_operand" "Upa")]
+	     SVE_BRKP)]
 	  UNSPEC_PTEST))
    (clobber (match_scratch:VNx16BI 0 "=Upa"))]
   "TARGET_SVE"
-  "brk<brk_op>s\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b, %3.b"
 )
 
 ;; -------------------------------------------------------------------------
--- a/src/gcc/config/aarch64/aarch64-tune.md
+++ b/src/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa65,cortexa65ae,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
+	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa65,cortexa65ae,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,neoversev2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
--- a/src/gcc/config/aarch64/aarch64.c
+++ b/src/gcc/config/aarch64/aarch64.c
@@ -19498,30 +19498,56 @@ aarch64_declare_function_name (FILE *stream, const char* name,
   cfun->machine->label_is_assembled = true;
 }
 
-/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  Check if the patch area is after
-   the function label and emit a BTI if necessary.  */
+/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  */
 
 void
 aarch64_print_patchable_function_entry (FILE *file,
 					unsigned HOST_WIDE_INT patch_area_size,
 					bool record_p)
 {
-  if (cfun->machine->label_is_assembled
-      && aarch64_bti_enabled ()
-      && !cgraph_node::get (cfun->decl)->only_called_directly_p ())
+  if (!cfun->machine->label_is_assembled)
     {
-      /* Remove the BTI that follows the patch area and insert a new BTI
-	 before the patch area right after the function label.  */
-      rtx_insn *insn = next_real_nondebug_insn (get_insns ());
-      if (insn
-	  && INSN_P (insn)
-	  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE
-	  && XINT (PATTERN (insn), 1) == UNSPECV_BTI_C)
-	delete_insn (insn);
-      asm_fprintf (file, "\thint\t34 // bti c\n");
+      /* Emit the patching area before the entry label, if any.  */
+      default_print_patchable_function_entry (file, patch_area_size,
+					      record_p);
+      return;
+    }
+
+  rtx pa = gen_patchable_area (GEN_INT (patch_area_size),
+			       GEN_INT (record_p));
+  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
+
+  if (!aarch64_bti_enabled ()
+      || cgraph_node::get (cfun->decl)->only_called_directly_p ())
+    {
+      /* Emit the patchable_area at the beginning of the function.  */
+      rtx_insn *insn = emit_insn_before (pa, BB_HEAD (bb));
+      INSN_ADDRESSES_NEW (insn, -1);
+      return;
+    }
+
+  rtx_insn *insn = next_real_nondebug_insn (get_insns ());
+  if (!insn
+      || !INSN_P (insn)
+      || GET_CODE (PATTERN (insn)) != UNSPEC_VOLATILE
+      || XINT (PATTERN (insn), 1) != UNSPECV_BTI_C)
+    {
+      /* Emit a BTI_C.  */
+      insn = emit_insn_before (gen_bti_c (), BB_HEAD (bb));
     }
 
-  default_print_patchable_function_entry (file, patch_area_size, record_p);
+  /* Emit the patchable_area after BTI_C.  */
+  insn = emit_insn_after (pa, insn);
+  INSN_ADDRESSES_NEW (insn, -1);
+}
+
+/* Output patchable area.  */
+
+void
+aarch64_output_patchable_area (unsigned int patch_area_size, bool record_p)
+{
+  default_print_patchable_function_entry (asm_out_file, patch_area_size,
+					  record_p);
 }
 
 /* Implement ASM_OUTPUT_DEF_FROM_DECLS.  Output .variant_pcs for aliases.  */
--- a/src/gcc/config/aarch64/aarch64.h
+++ b/src/gcc/config/aarch64/aarch64.h
@@ -236,7 +236,7 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_FL_FOR_ARCH8_2			\
   (AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_V8_2)
 #define AARCH64_FL_FOR_ARCH8_3			\
-  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3)
+  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3 | AARCH64_FL_RCPC)
 #define AARCH64_FL_FOR_ARCH8_4			\
   (AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_V8_4 | AARCH64_FL_F16FML \
    | AARCH64_FL_DOTPROD | AARCH64_FL_RCPC8_4)
@@ -271,6 +271,7 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_ISA_SM4	           (aarch64_isa_flags & AARCH64_FL_SM4)
 #define AARCH64_ISA_SHA3	   (aarch64_isa_flags & AARCH64_FL_SHA3)
 #define AARCH64_ISA_F16FML	   (aarch64_isa_flags & AARCH64_FL_F16FML)
+#define AARCH64_ISA_RCPC	   (aarch64_isa_flags & AARCH64_FL_RCPC)
 #define AARCH64_ISA_RCPC8_4	   (aarch64_isa_flags & AARCH64_FL_RCPC8_4)
 #define AARCH64_ISA_RNG		   (aarch64_isa_flags & AARCH64_FL_RNG)
 #define AARCH64_ISA_V8_5	   (aarch64_isa_flags & AARCH64_FL_V8_5)
--- a/src/gcc/config/aarch64/aarch64.md
+++ b/src/gcc/config/aarch64/aarch64.md
@@ -282,6 +282,7 @@ (define_c_enum "unspec" [
     UNSPEC_TAG_SPACE		; Translate address to MTE tag address space.
     UNSPEC_LD1RO
     UNSPEC_SALT_ADDR
+    UNSPECV_PATCHABLE_AREA
 ])
 
 (define_c_enum "unspecv" [
@@ -7606,6 +7607,19 @@ (define_insn "stg"
   [(set_attr "type" "memtag")]
 )
 
+(define_insn "patchable_area"
+  [(unspec_volatile [(match_operand 0 "const_int_operand")
+		     (match_operand 1 "const_int_operand")]
+		    UNSPECV_PATCHABLE_AREA)]
+  ""
+{
+  aarch64_output_patchable_area (INTVAL (operands[0]),
+			         INTVAL (operands[1]) != 0);
+  return "";
+}
+  [(set (attr "length") (symbol_ref "INTVAL (operands[0])"))]
+)
+
 ;; AdvSIMD Stuff
 (include "aarch64-simd.md")
 
--- a/src/gcc/config/aarch64/iterators.md
+++ b/src/gcc/config/aarch64/iterators.md
@@ -2660,6 +2660,8 @@ (define_int_iterator FRINTNZX [UNSPEC_FRINT32Z UNSPEC_FRINT32X
 
 (define_int_iterator SVE_BRK_UNARY [UNSPEC_BRKA UNSPEC_BRKB])
 
+(define_int_iterator SVE_BRKP [UNSPEC_BRKPA UNSPEC_BRKPB])
+
 (define_int_iterator SVE_BRK_BINARY [UNSPEC_BRKN UNSPEC_BRKPA UNSPEC_BRKPB])
 
 (define_int_iterator SVE_PITER [UNSPEC_PFIRST UNSPEC_PNEXT])
--- a/src/gcc/config/i386/i386-expand.c
+++ b/src/gcc/config/i386/i386-expand.c
@@ -10955,7 +10955,7 @@ ix86_expand_vec_set_builtin (tree exp)
   op1 = expand_expr (arg1, NULL_RTX, mode1, EXPAND_NORMAL);
   elt = get_element_number (TREE_TYPE (arg0), arg2);
 
-  if (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode)
+  if (GET_MODE (op1) != mode1)
     op1 = convert_modes (mode1, GET_MODE (op1), op1, true);
 
   op0 = force_reg (tmode, op0);
--- a/src/gcc/config/i386/t-i386
+++ b/src/gcc/config/i386/t-i386
@@ -61,7 +61,12 @@ i386-features.o: $(srcdir)/config/i386/i386-features.c
 	$(COMPILE) $<
 	$(POSTCOMPILE)
 
+# i386-builtin-types.inc is included into i386-builtins.h.
+# Below are direct users of i386-builtins.h:
 i386.o: i386-builtin-types.inc
+i386-builtins.o: i386-builtin-types.inc
+i386-expand.o: i386-builtin-types.inc
+i386-features.o: i386-builtin-types.inc
 
 i386-builtin-types.inc: s-i386-bt ; @true
 s-i386-bt: $(srcdir)/config/i386/i386-builtin-types.awk \
--- a/src/gcc/config/nvptx/nvptx.c
+++ b/src/gcc/config/nvptx/nvptx.c
@@ -4392,6 +4392,7 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
   rtx_insn *neuter_start = NULL;
   rtx_insn *worker_label = NULL, *vector_label = NULL;
   rtx_insn *worker_jump = NULL, *vector_jump = NULL;
+  rtx_insn *warp_sync = NULL;
   for (mode = GOMP_DIM_WORKER; mode <= GOMP_DIM_VECTOR; mode++)
     if (GOMP_DIM_MASK (mode) & skip_mask)
       {
@@ -4424,11 +4425,29 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
 	if (tail_branch)
 	  {
 	    label_insn = emit_label_before (label, before);
+	    if (mode == GOMP_DIM_VECTOR)
+	      {
+		if (TARGET_PTX_6_0)
+		  warp_sync = emit_insn_after (gen_nvptx_warpsync (),
+					       label_insn);
+		else
+		  warp_sync = emit_insn_after (gen_nvptx_uniform_warp_check (),
+					       label_insn);
+	      }
 	    before = label_insn;
 	  }
 	else
 	  {
 	    label_insn = emit_label_after (label, tail);
+	    if (mode == GOMP_DIM_VECTOR)
+	      {
+		if (TARGET_PTX_6_0)
+		  warp_sync = emit_insn_after (gen_nvptx_warpsync (),
+					       label_insn);
+		else
+		  warp_sync = emit_insn_after (gen_nvptx_uniform_warp_check (),
+					       label_insn);
+	      }
 	    if ((mode == GOMP_DIM_VECTOR || mode == GOMP_DIM_WORKER)
 		&& CALL_P (tail) && find_reg_note (tail, REG_NORETURN, NULL))
 	      emit_insn_after (gen_exit (), label_insn);
@@ -4496,6 +4515,8 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
 		 setp.ne.u32 %rcond,%rcondu32,0;
 	  */
 	  rtx_insn *label = PREV_INSN (tail);
+	  if (label == warp_sync)
+	    label = PREV_INSN (label);
 	  gcc_assert (label && LABEL_P (label));
 	  rtx tmp = gen_reg_rtx (BImode);
 	  emit_insn_before (gen_movbi (tmp, const0_rtx),
--- a/src/gcc/config/nvptx/nvptx.h
+++ b/src/gcc/config/nvptx/nvptx.h
@@ -27,7 +27,7 @@
 
 /* Run-time Target.  */
 
-#define STARTFILE_SPEC "%{mmainkernel:crt0.o}"
+#define STARTFILE_SPEC "%{mmainkernel:crt0.o%s}"
 
 #define ASM_SPEC "%{misa=*:-m %*}"
 
@@ -95,6 +95,9 @@
 
 #define TARGET_SM35 (ptx_isa_option >= PTX_ISA_SM35)
 
+/* 'TARGET_PTX_*' not applicable before GCC 12.  */
+#define TARGET_PTX_6_0 false
+
 /* Registers.  Since ptx is a virtual target, we just define a few
    hard registers for special purposes and leave pseudos unallocated.
    We have to have some available hard registers, to keep gcc setup
--- a/src/gcc/config/nvptx/nvptx.md
+++ b/src/gcc/config/nvptx/nvptx.md
@@ -55,6 +55,8 @@ (define_c_enum "unspecv" [
    UNSPECV_CAS
    UNSPECV_XCHG
    UNSPECV_BARSYNC
+   UNSPECV_WARPSYNC
+   UNSPECV_UNIFORM_WARP_CHECK
    UNSPECV_MEMBAR
    UNSPECV_MEMBAR_CTA
    UNSPECV_DIM_POS
@@ -1476,6 +1478,29 @@ (define_insn "nvptx_barsync"
   }
   [(set_attr "predicable" "false")])
 
+(define_insn "nvptx_warpsync"
+  [(unspec_volatile [(const_int 0)] UNSPECV_WARPSYNC)]
+  "TARGET_PTX_6_0"
+  "\\tbar.warp.sync\\t0xffffffff;"
+  [(set_attr "predicable" "false")])
+
+(define_insn "nvptx_uniform_warp_check"
+  [(unspec_volatile [(const_int 0)] UNSPECV_UNIFORM_WARP_CHECK)]
+  ""
+  {
+    output_asm_insn ("{", NULL);
+    output_asm_insn ("\\t"	 ".reg.b32"	   "\\t" "act;", NULL);
+    output_asm_insn ("\\t"	 "vote.ballot.b32" "\\t" "act,1;", NULL);
+    output_asm_insn ("\\t"	 ".reg.pred"	   "\\t" "uni;", NULL);
+    output_asm_insn ("\\t"	 "setp.eq.b32"	   "\\t" "uni,act,0xffffffff;",
+		     NULL);
+    output_asm_insn ("@ !uni\\t" "trap;", NULL);
+    output_asm_insn ("@ !uni\\t" "exit;", NULL);
+    output_asm_insn ("}", NULL);
+    return "";
+  }
+  [(set_attr "predicable" "false")])
+
 (define_expand "memory_barrier"
   [(set (match_dup 0)
 	(unspec_volatile:BLK [(match_dup 0)] UNSPECV_MEMBAR))]
--- a/src/gcc/config/pa/pa.md
+++ b/src/gcc/config/pa/pa.md
@@ -5071,23 +5071,25 @@ (define_expand "addvdi3"
 						    (match_dup 2))))
 		       (const_int 0))])]
   ""
-  "")
+  "
+{
+  if (TARGET_64BIT)
+    operands[2] = force_reg (DImode, operands[2]);
+}")
 
 (define_insn ""
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(plus:DI (match_operand:DI 1 "reg_or_0_operand" "%rM,rM")
-		 (match_operand:DI 2 "arith11_operand" "r,I")))
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "reg_or_0_operand" "%rM")
+		 (match_operand:DI 2 "register_operand" "r")))
    (trap_if (ne (plus:TI (sign_extend:TI (match_dup 1))
 			 (sign_extend:TI (match_dup 2)))
 		(sign_extend:TI (plus:DI (match_dup 1)
 					 (match_dup 2))))
 	    (const_int 0))]
   "TARGET_64BIT"
-  "@
-  add,tsv,* %2,%1,%0
-  addi,tsv,* %2,%1,%0"
-  [(set_attr "type" "binary,binary")
-   (set_attr "length" "4,4")])
+  "add,tsv,* %2,%1,%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -5262,23 +5264,25 @@ (define_expand "subvdi3"
 						     (match_dup 2))))
 		       (const_int 0))])]
   ""
-  "")
+  "
+{
+  if (TARGET_64BIT)
+    operands[1] = force_reg (DImode, operands[1]);
+}")
 
 (define_insn ""
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(minus:DI (match_operand:DI 1 "arith11_operand" "r,I")
-		  (match_operand:DI 2 "reg_or_0_operand" "rM,rM")))
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(minus:DI (match_operand:DI 1 "register_operand" "r")
+		  (match_operand:DI 2 "reg_or_0_operand" "rM")))
    (trap_if (ne (minus:TI (sign_extend:TI (match_dup 1))
 			  (sign_extend:TI (match_dup 2)))
 		(sign_extend:TI (minus:DI (match_dup 1)
 					  (match_dup 2))))
 	    (const_int 0))]
   "TARGET_64BIT"
-  "@
-  {subo|sub,tsv} %1,%2,%0
-  {subio|subi,tsv} %1,%2,%0"
-  [(set_attr "type" "binary,binary")
-   (set_attr "length" "4,4")])
+  "sub,tsv,* %1,%2,%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,&r")
--- a/src/gcc/config/rs6000/mma.md
+++ b/src/gcc/config/rs6000/mma.md
@@ -283,10 +283,28 @@ (define_expand "movoi"
 (define_expand "movpoi"
   [(set (match_operand:POI 0 "nonimmediate_operand")
 	(match_operand:POI 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], POImode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], POImode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  As shown in that PR, without one
+	 explicit mov optab on POImode provided, it would call emit_move_insn
+	 recursively.  So we allow this pattern to be generated when we are
+	 expanding to RTL and have seen errors.  It would not cause further ICEs
+	 as the compilation would stop soon after expanding.  */
+    }
+  else if (rs6000_opaque_type_invalid_use_p (currently_expanding_gimple_stmt))
+    ;
+  else
+    /* Catch unexpected cases.  */
+    gcc_assert (false);
 })
 
 (define_insn_and_split "*movpoi"
@@ -323,10 +341,25 @@ (define_expand "movxi"
 (define_expand "movpxi"
   [(set (match_operand:PXI 0 "nonimmediate_operand")
 	(match_operand:PXI 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], PXImode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], PXImode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  So do the same handlings for PXImode
+	 as POImode here.  */
+    }
+  else if (rs6000_opaque_type_invalid_use_p (currently_expanding_gimple_stmt))
+    ;
+  else
+    /* Catch unexpected cases.  */
+    gcc_assert (false);
 })
 
 (define_insn_and_split "*movpxi"
--- a/src/gcc/config/rs6000/rs6000-call.c
+++ b/src/gcc/config/rs6000/rs6000-call.c
@@ -6534,6 +6534,12 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,
 	{
 	  cum->vregno += n_elts;
 
+	  /* If we are not splitting Complex IEEE128 args then account for the
+	     fact that they are passed in 2 VSX regs. */
+	  if (!targetm.calls.split_complex_arg && type
+	      && TREE_CODE (type) == COMPLEX_TYPE && elt_mode == KCmode)
+	    cum->vregno++;
+
 	  if (!TARGET_ALTIVEC)
 	    error ("cannot pass argument in vector register because"
 		   " altivec instructions are disabled, use %qs"
@@ -10855,7 +10861,12 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
       push_gimplify_context (true);
       tree dst_ptr = gimple_call_arg (stmt, 0);
       tree src_ptr = gimple_call_arg (stmt, 1);
-      tree src_type = TREE_TYPE (src_ptr);
+      tree src_type = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC)
+		      ? build_pointer_type (vector_quad_type_node)
+		      : build_pointer_type (vector_pair_type_node);
+      if (TREE_TYPE (src_ptr) != src_type)
+	src_ptr = build1 (NOP_EXPR, src_type, src_ptr);
+
       tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));
       gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);
 
--- a/src/gcc/config/rs6000/rs6000-logue.c
+++ b/src/gcc/config/rs6000/rs6000-logue.c
@@ -4885,7 +4885,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)
 	 a REG_CFA_DEF_CFA note, but that's OK;  A duplicate is
 	 discarded by dwarf2cfi.c/dwarf2out.c, and in any case would
 	 be harmless if emitted.  */
-      if (frame_pointer_needed)
+      if (frame_pointer_needed_indeed)
 	{
 	  insn = get_last_insn ();
 	  add_reg_note (insn, REG_CFA_DEF_CFA,
--- a/src/gcc/config/rs6000/rs6000-p8swap.c
+++ b/src/gcc/config/rs6000/rs6000-p8swap.c
@@ -1668,7 +1668,15 @@ replace_swapped_aligned_store (swap_web_entry *insn_entry,
   gcc_assert ((GET_CODE (new_body) == SET)
 	      && MEM_P (SET_DEST (new_body)));
 
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (store_insn));
+  basic_block bb = BLOCK_FOR_INSN (store_insn);
+  set_block_for_insn (new_insn, bb);
+  /* Handle REG_EH_REGION note.  */
+  if (cfun->can_throw_non_call_exceptions && BB_END (bb) == store_insn)
+    {
+      rtx note = find_reg_note (store_insn, REG_EH_REGION, NULL_RTX);
+      if (note)
+	add_reg_note (new_insn, REG_EH_REGION, XEXP (note, 0));
+    }
   df_insn_rescan (new_insn);
 
   df_insn_delete (store_insn);
@@ -1761,7 +1769,15 @@ replace_swapped_aligned_load (swap_web_entry *insn_entry, rtx swap_insn)
   gcc_assert ((GET_CODE (new_body) == SET)
 	      && MEM_P (SET_SRC (new_body)));
 
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (def_insn));
+  basic_block bb = BLOCK_FOR_INSN (def_insn);
+  set_block_for_insn (new_insn, bb);
+  /* Handle REG_EH_REGION note.  */
+  if (cfun->can_throw_non_call_exceptions && BB_END (bb) == def_insn)
+    {
+      rtx note = find_reg_note (def_insn, REG_EH_REGION, NULL_RTX);
+      if (note)
+	add_reg_note (new_insn, REG_EH_REGION, XEXP (note, 0));
+    }
   df_insn_rescan (new_insn);
 
   df_insn_delete (def_insn);
--- a/src/gcc/config/rs6000/rs6000-protos.h
+++ b/src/gcc/config/rs6000/rs6000-protos.h
@@ -309,4 +309,6 @@ extern bool rs6000_quadword_masked_address_p (const_rtx exp);
 extern rtx rs6000_gen_lvx (enum machine_mode, rtx, rtx);
 extern rtx rs6000_gen_stvx (enum machine_mode, rtx, rtx);
 
+extern gimple *currently_expanding_gimple_stmt;
+extern bool rs6000_opaque_type_invalid_use_p (gimple *);
 #endif  /* rs6000-protos.h */
--- a/src/gcc/config/rs6000/rs6000.c
+++ b/src/gcc/config/rs6000/rs6000.c
@@ -26888,31 +26888,47 @@ rs6000_invalid_conversion (const_tree fromtype, const_tree totype)
       if (tomode == POImode)
 	return N_("invalid conversion to type %<__vector_pair%>");
     }
-  else if (POINTER_TYPE_P (fromtype) && POINTER_TYPE_P (totype))
-    {
-      /* We really care about the modes of the base types.  */
-      frommode = TYPE_MODE (TREE_TYPE (fromtype));
-      tomode = TYPE_MODE (TREE_TYPE (totype));
 
-      /* Do not allow conversions to/from PXImode and POImode pointer
-	 types, except to/from void pointers.  */
-      if (frommode != tomode
-	  && frommode != VOIDmode
-	  && tomode != VOIDmode)
+  /* Conversion allowed.  */
+  return NULL;
+}
+
+/* Now we have only two opaque types, they are __vector_quad and
+   __vector_pair built-in types.  They are target specific and
+   only available when MMA is supported.  With MMA supported, it
+   simply returns true, otherwise it checks if the given gimple
+   STMT is an assignment stmt and uses either of these two opaque
+   types unexpectedly, if yes, it would raise an error message
+   and returns true, otherwise it returns false.  */
+
+bool
+rs6000_opaque_type_invalid_use_p (gimple *stmt)
+{
+  if (TARGET_MMA)
+    return false;
+
+  if (stmt)
+    {
+      /* The usage of MMA opaque types is very limited for now,
+	 to check with gassign is enough so far.  */
+      if (gassign *ga = dyn_cast<gassign *> (stmt))
 	{
-	  if (frommode == PXImode)
-	    return N_("invalid conversion from type %<* __vector_quad%>");
-	  if (tomode == PXImode)
-	    return N_("invalid conversion to type %<* __vector_quad%>");
-	  if (frommode == POImode)
-	    return N_("invalid conversion from type %<* __vector_pair%>");
-	  if (tomode == POImode)
-	    return N_("invalid conversion to type %<* __vector_pair%>");
+	  tree lhs = gimple_assign_lhs (ga);
+	  tree type = TREE_TYPE (lhs);
+	  if (type == vector_quad_type_node)
+	    {
+	      error ("type %<__vector_quad%> requires the %qs option", "-mmma");
+	      return true;
+	    }
+	  else if (type == vector_pair_type_node)
+	    {
+	      error ("type %<__vector_pair%> requires the %qs option", "-mmma");
+	      return true;
+	    }
 	}
     }
 
-  /* Conversion allowed.  */
-  return NULL;
+  return false;
 }
 
 struct gcc_target targetm = TARGET_INITIALIZER;
--- a/src/gcc/config/rs6000/rs6000.h
+++ b/src/gcc/config/rs6000/rs6000.h
@@ -81,12 +81,15 @@
 # define SUBTARGET_DRIVER_SELF_SPECS ""
 #endif
 
-/* Only for use in the testsuite: -mdejagnu-cpu= simply overrides -mcpu=.
+/* Only for use in the testsuite: -mdejagnu-cpu=<value> filters out all
+   -mcpu= as well as -mtune= options then simply adds -mcpu=<value>,
+   while -mdejagnu-tune=<value> filters out all -mtune= options then
+   simply adds -mtune=<value>.
    With older versions of Dejagnu the command line arguments you set in
-   RUNTESTFLAGS override those set in the testcases; with this option,
-   the testcase will always win.  Ditto for -mdejagnu-tune=.  */
+   RUNTESTFLAGS override those set in the testcases; with these options,
+   the testcase will always win.  */
 #define DRIVER_SELF_SPECS \
-  "%{mdejagnu-cpu=*: %<mcpu=* -mcpu=%*}", \
+  "%{mdejagnu-cpu=*: %<mcpu=* %<mtune=* -mcpu=%*}", \
   "%{mdejagnu-tune=*: %<mtune=* -mtune=%*}", \
   "%{mdejagnu-*: %<mdejagnu-*}", \
    SUBTARGET_DRIVER_SELF_SPECS
--- a/src/gcc/config/rs6000/rs6000.md
+++ b/src/gcc/config/rs6000/rs6000.md
@@ -782,8 +782,8 @@ (define_mode_iterator ALTIVEC_DFORM [DF
 ;; complex forms.  Basic data transfer is done later.
 
 (define_insn "zero_extendqi<mode>2"
-  [(set (match_operand:EXTQI 0 "gpc_reg_operand" "=r,r,^wa,^v")
-	(zero_extend:EXTQI (match_operand:QI 1 "reg_or_mem_operand" "m,r,Z,v")))]
+  [(set (match_operand:EXTQI 0 "gpc_reg_operand" "=r,r,wa,^v")
+	(zero_extend:EXTQI (match_operand:QI 1 "reg_or_mem_operand" "m,r,?Z,v")))]
   ""
   "@
    lbz%U1%X1 %0,%1
@@ -836,8 +836,8 @@ (define_insn_and_split "*zero_extendqi<mode>2_dot2"
 
 
 (define_insn "zero_extendhi<mode>2"
-  [(set (match_operand:EXTHI 0 "gpc_reg_operand" "=r,r,^wa,^v")
-	(zero_extend:EXTHI (match_operand:HI 1 "reg_or_mem_operand" "m,r,Z,v")))]
+  [(set (match_operand:EXTHI 0 "gpc_reg_operand" "=r,r,wa,^v")
+	(zero_extend:EXTHI (match_operand:HI 1 "reg_or_mem_operand" "m,r,?Z,v")))]
   ""
   "@
    lhz%U1%X1 %0,%1
@@ -891,7 +891,7 @@ (define_insn_and_split "*zero_extendhi<mode>2_dot2"
 
 (define_insn "zero_extendsi<mode>2"
   [(set (match_operand:EXTSI 0 "gpc_reg_operand" "=r,r,d,wa,wa,r,wa")
-	(zero_extend:EXTSI (match_operand:SI 1 "reg_or_mem_operand" "m,r,Z,Z,r,wa,wa")))]
+	(zero_extend:EXTSI (match_operand:SI 1 "reg_or_mem_operand" "m,r,?Z,?Z,r,wa,wa")))]
   ""
   "@
    lwz%U1%X1 %0,%1
@@ -6941,7 +6941,7 @@ (define_insn "*movsi_internal1"
   [(set (match_operand:SI 0 "nonimmediate_operand"
 	  "=r,         r,
 	   r,          d,          v,
-	   m,          Z,          Z,
+	   m,          ?Z,         ?Z,
 	   r,          r,          r,          r,
 	   wa,         wa,         wa,         v,
 	   wa,         v,          v,
@@ -6949,7 +6949,7 @@ (define_insn "*movsi_internal1"
 	   r,          *h,         *h")
 	(match_operand:SI 1 "input_operand"
 	  "r,          U,
-	   m,          Z,          Z,
+	   m,          ?Z,         ?Z,
 	   r,          d,          v,
 	   I,          L,          eI,         n,
 	   wa,         O,          wM,         wB,
@@ -7230,11 +7230,11 @@ (define_expand "mov<mode>"
 ;;		MTVSRWZ     MF%1       MT%1       NOP
 (define_insn "*mov<mode>_internal"
   [(set (match_operand:QHI 0 "nonimmediate_operand"
-		"=r,        r,         wa,        m,         Z,         r,
+		"=r,        r,         wa,        m,         ?Z,        r,
 		 wa,        wa,        wa,        v,         ?v,        r,
 		 wa,        r,         *c*l,      *h")
 	(match_operand:QHI 1 "input_operand"
-		"r,         m,         Z,         r,         wa,        i,
+		"r,         m,         ?Z,        r,         wa,        i,
 		 wa,        O,         wM,        wB,        wS,        wa,
 		 r,         *h,        r,         0"))]
   "gpc_reg_operand (operands[0], <MODE>mode)
@@ -7413,10 +7413,10 @@ (define_insn "movsf_hardfloat"
 ;;	FMR          MR         MT%0       MF%1       NOP
 (define_insn "movsd_hardfloat"
   [(set (match_operand:SD 0 "nonimmediate_operand"
-	 "=!r,       d,         m,         Z,         ?d,        ?r,
+	 "=!r,       d,         m,         ?Z,        ?d,        ?r,
 	  f,         !r,        *c*l,      !r,        *h")
 	(match_operand:SD 1 "input_operand"
-	 "m,         Z,         r,         wx,        r,         d,
+	 "m,         ?Z,        r,         wx,        r,         d,
 	  f,         r,         r,         *h,        0"))]
   "(register_operand (operands[0], SDmode)
    || register_operand (operands[1], SDmode))
--- a/src/gcc/config/rs6000/rtems.h
+++ b/src/gcc/config/rs6000/rtems.h
@@ -23,6 +23,9 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
+/* Undef gnu-user.h macro we don't want.  */
+#undef CPLUSPLUS_CPP_SPEC
+
 /* Copy and paste from linux64.h and freebsd64.h */
 #ifdef IN_LIBGCC2
 #undef TARGET_64BIT
@@ -252,7 +255,8 @@
 %{mcpu=821:  %{!Dppc*: %{!Dmpc*: -Dmpc821}  } } \
 %{mcpu=860:  %{!Dppc*: %{!Dmpc*: -Dmpc860}  } } \
 %{mcpu=8540: %{!Dppc*: %{!Dmpc*: -Dppc8540}  } } \
-%{mcpu=e6500: -D__PPC_CPU_E6500__}"
+%{mcpu=e6500: -D__PPC_CPU_E6500__} \
+%{mvrsave: -D__PPC_VRSAVE__}"
 
 #undef	ASM_SPEC
 #define	ASM_SPEC "%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)"
--- a/src/gcc/config/rs6000/t-rtems
+++ b/src/gcc/config/rs6000/t-rtems
@@ -36,6 +36,9 @@ MULTILIB_DIRNAMES += nof
 MULTILIB_OPTIONS += mno-altivec
 MULTILIB_DIRNAMES += noaltivec
 
+MULTILIB_OPTIONS += mvrsave
+MULTILIB_DIRNAMES += vrsave
+
 MULTILIB_MATCHES  	+= ${MULTILIB_MATCHES_ENDIAN}
 MULTILIB_MATCHES	+= ${MULTILIB_MATCHES_SYSV}
 # Map 405 to 403
@@ -70,5 +73,7 @@ MULTILIB_REQUIRED += mcpu=7400/msoft-float
 MULTILIB_REQUIRED += mcpu=8540/msoft-float
 MULTILIB_REQUIRED += mcpu=860
 MULTILIB_REQUIRED += mcpu=e6500/m32
+MULTILIB_REQUIRED += mcpu=e6500/m32/mvrsave
 MULTILIB_REQUIRED += mcpu=e6500/m32/msoft-float/mno-altivec
 MULTILIB_REQUIRED += mcpu=e6500/m64
+MULTILIB_REQUIRED += mcpu=e6500/m64/mvrsave
--- a/src/gcc/config/s390/s390.c
+++ b/src/gcc/config/s390/s390.c
@@ -13465,36 +13465,37 @@ s390_call_saved_register_used (tree call_expr)
       function_arg_info arg (TREE_TYPE (parameter), /*named=*/true);
       apply_pass_by_reference_rules (&cum_v, arg);
 
-       parm_rtx = s390_function_arg (cum, arg);
+      parm_rtx = s390_function_arg (cum, arg);
 
-       s390_function_arg_advance (cum, arg);
+      s390_function_arg_advance (cum, arg);
 
-       if (!parm_rtx)
-	 continue;
-
-       if (REG_P (parm_rtx))
-	 {
-	   for (reg = 0; reg < REG_NREGS (parm_rtx); reg++)
-	     if (!call_used_or_fixed_reg_p (reg + REGNO (parm_rtx)))
-	       return true;
-	 }
+      if (!parm_rtx)
+	continue;
 
-       if (GET_CODE (parm_rtx) == PARALLEL)
-	 {
-	   int i;
+      if (REG_P (parm_rtx))
+	{
+	  int size = s390_function_arg_size (arg.mode, arg.type);
+	  int nregs = (size + UNITS_PER_LONG - 1) / UNITS_PER_LONG;
 
-	   for (i = 0; i < XVECLEN (parm_rtx, 0); i++)
-	     {
-	       rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);
+	  for (reg = 0; reg < nregs; reg++)
+	    if (!call_used_or_fixed_reg_p (reg + REGNO (parm_rtx)))
+	      return true;
+	}
+      else if (GET_CODE (parm_rtx) == PARALLEL)
+	{
+	  int i;
 
-	       gcc_assert (REG_P (r));
+	  for (i = 0; i < XVECLEN (parm_rtx, 0); i++)
+	    {
+	      rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);
 
-	       for (reg = 0; reg < REG_NREGS (r); reg++)
-		 if (!call_used_or_fixed_reg_p (reg + REGNO (r)))
-		   return true;
-	     }
-	 }
+	      gcc_assert (REG_P (r));
+	      gcc_assert (REG_NREGS (r) == 1);
 
+	      if (!call_used_or_fixed_reg_p (REGNO (r)))
+		return true;
+	    }
+	}
     }
   return false;
 }
--- a/src/gcc/config/sparc/sparc.c
+++ b/src/gcc/config/sparc/sparc.c
@@ -6118,6 +6118,9 @@ sparc_expand_prologue (void)
 	}
 
       RTX_FRAME_RELATED_P (insn) = 1;
+
+      /* Ensure no memory access is done before the frame is established.  */
+      emit_insn (gen_frame_blockage ());
     }
   else
     {
@@ -6132,13 +6135,7 @@ sparc_expand_prologue (void)
 	  /* %sp is not the CFA register anymore.  */
 	  emit_insn (gen_stack_pointer_inc (GEN_INT (4096 - size)));
 
-	  /* Make sure no %fp-based store is issued until after the frame is
-	     established.  The offset between the frame pointer and the stack
-	     pointer is calculated relative to the value of the stack pointer
-	     at the end of the function prologue, and moving instructions that
-	     access the stack via the frame pointer between the instructions
-	     that decrement the stack pointer could result in accessing the
-	     register window save area, which is volatile.  */
+	  /* Likewise.  */
 	  emit_insn (gen_frame_blockage ());
 	}
       else
@@ -6234,8 +6231,8 @@ sparc_flat_expand_prologue (void)
 	}
       RTX_FRAME_RELATED_P (insn) = 1;
 
-      /* Ensure nothing is scheduled until after the frame is established.  */
-      emit_insn (gen_blockage ());
+      /* Ensure no memory access is done before the frame is established.  */
+      emit_insn (gen_frame_blockage ());
 
       if (frame_pointer_needed)
 	{
@@ -6322,6 +6319,9 @@ sparc_expand_epilogue (bool for_eh)
     ; /* do nothing.  */
   else if (sparc_leaf_function_p)
     {
+      /* Ensure no memory access is done after the frame is destroyed.  */
+      emit_insn (gen_frame_blockage ());
+
       if (size <= 4096)
 	emit_insn (gen_stack_pointer_inc (GEN_INT (size)));
       else if (size <= 8192)
@@ -6372,15 +6372,15 @@ sparc_flat_expand_epilogue (bool for_eh)
     ; /* do nothing.  */
   else if (frame_pointer_needed)
     {
-      /* Make sure the frame is destroyed after everything else is done.  */
-      emit_insn (gen_blockage ());
+      /* Ensure no memory access is done after the frame is destroyed.  */
+      emit_insn (gen_frame_blockage ());
 
       emit_move_insn (stack_pointer_rtx, gen_rtx_REG (Pmode, 1));
     }
   else
     {
       /* Likewise.  */
-      emit_insn (gen_blockage ());
+      emit_insn (gen_frame_blockage ());
 
       if (size <= 4096)
 	emit_insn (gen_stack_pointer_inc (GEN_INT (size)));
--- a/src/gcc/cp/ChangeLog
+++ b/src/gcc/cp/ChangeLog
@@ -1,3 +1,27 @@
+2022-12-16  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-10-28  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102780
+	PR c++/108138
+	* constexpr.c (potential_constant_expression_1) <case TRUTH_*_EXPR>:
+	When tf_error isn't set, preemptively check potentiality of the
+	second operand before performing trial evaluation of the first
+	operand.
+	(potential_constant_expression_1): When tf_error is set, first check
+	potentiality quietly and return true if successful, otherwise
+	proceed noisily to give errors.
+
+2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/104066
+	* decl.c (grokdeclarator): Check funcdecl_p before complaining
+	about constinit.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/gcc/cp/constexpr.c
+++ b/src/gcc/cp/constexpr.c
@@ -8425,13 +8425,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
       tmp = boolean_false_node;
     truth:
       {
-	tree op = TREE_OPERAND (t, 0);
-	if (!RECUR (op, rval))
+	tree op0 = TREE_OPERAND (t, 0);
+	tree op1 = TREE_OPERAND (t, 1);
+	if (!RECUR (op0, rval))
 	  return false;
+	if (!(flags & tf_error) && RECUR (op1, rval))
+	  /* When quiet, try to avoid expensive trial evaluation by first
+	     checking potentiality of the second operand.  */
+	  return true;
 	if (!processing_template_decl)
-	  op = cxx_eval_outermost_constant_expr (op, true);
-	if (tree_int_cst_equal (op, tmp))
-	  return RECUR (TREE_OPERAND (t, 1), rval);
+	  op0 = cxx_eval_outermost_constant_expr (op0, true);
+	if (tree_int_cst_equal (op0, tmp))
+	  return (flags & tf_error) ? RECUR (op1, rval) : false;
 	else
 	  return true;
       }
@@ -8611,6 +8616,17 @@ bool
 potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 				 tsubst_flags_t flags)
 {
+  if (flags & tf_error)
+    {
+      /* Check potentiality quietly first, as that could be performed more
+	 efficiently in some cases (currently only for TRUTH_*_EXPR).  If
+	 that fails, replay the check noisily to give errors.  */
+      flags &= ~tf_error;
+      if (potential_constant_expression_1 (t, want_rval, strict, now, flags))
+	return true;
+      flags |= tf_error;
+    }
+
   tree target = NULL_TREE;
   return potential_constant_expression_1 (t, want_rval, strict, now,
 					  flags, &target);
--- a/src/gcc/cp/decl.c
+++ b/src/gcc/cp/decl.c
@@ -12275,7 +12275,7 @@ grokdeclarator (const cp_declarator *declarator,
 			  "an array", name);
 		return error_mark_node;
 	      }
-	    if (constinit_p)
+	    if (constinit_p && funcdecl_p)
 	      {
 		error_at (declspecs->locations[ds_constinit],
 			  "%<constinit%> on function return type is not "
--- a/src/gcc/d/ChangeLog
+++ b/src/gcc/d/ChangeLog
@@ -1,3 +1,48 @@
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108050
+	* decl.cc (DeclVisitor::visit (Import *)): Handle build_import_decl
+	returning a TREE_LIST.
+	* imports.cc (ImportVisitor::visit (OverloadSet *)): New override.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/107592
+	* toir.cc (IRVisitor::push_unrolled_continue_label): New method.
+	(IRVisitor::pop_unrolled_continue_label): New method.
+	(IRVisitor::visit (UnrolledLoopStatement *)): Use them instead of
+	push_continue_label and pop_continue_label.
+
+2022-08-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-08-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106638
+	* gdc.texi: Update DIP links to point at upstream dlang/DIPs
+	repository.
+
+2022-07-05  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-07-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106139
+	* d-convert.cc (convert_expr): Handle casting from array to vector.
+	(convert_for_rvalue): Rewrite vector to array casts of the same
+	element type into a constructor.
+	(convert_for_assignment): Return calling convert_for_rvalue.
+	* dmd/expressionsem.c (ExpressionSemanticVisitor::visit): Run semantic
+	on vector expression after lowering.
+	* expr.cc (ExprVisitor::visit (VectorExp *)): Handle generating a
+	vector expression from a static array.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/gcc/d/d-convert.cc
+++ b/src/gcc/d/d-convert.cc
@@ -502,6 +502,15 @@ convert_expr (tree exp, Type *etype, Type *totype)
 	  gcc_assert (totype->size () == etype->size ());
 	  result = build_vconvert (build_ctype (totype), exp);
 	}
+      else if (tbtype->ty == Tvector && tbtype->size () == ebtype->size ())
+	{
+	  /* Allow casting from array to vector as if its an unaligned load.  */
+	  tree type = build_ctype (totype);
+	  tree unaligned_type = build_variant_type_copy (type);
+	  SET_TYPE_ALIGN (unaligned_type, 1 * BITS_PER_UNIT);
+	  TYPE_USER_ALIGN (unaligned_type) = 1;
+	  result = convert (type, build_vconvert (unaligned_type, exp));
+	}
       else
 	{
 	  error ("cannot cast expression of type %qs to type %qs",
@@ -634,6 +643,39 @@ convert_for_rvalue (tree expr, Type *etype, Type *totype)
       break;
     }
 
+  if (tbtype->ty == Tsarray
+      && ebtype->ty == Tsarray
+      && tbtype->nextOf ()->ty == ebtype->nextOf ()->ty
+      && INDIRECT_REF_P (expr)
+      && CONVERT_EXPR_CODE_P (TREE_CODE (TREE_OPERAND (expr, 0)))
+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (expr, 0), 0)) == ADDR_EXPR)
+    {
+      /* If expression is a vector that was casted to an array either by
+	 explicit type cast or by taking the vector's `.array' value, strip the
+	 reinterpret cast and build a constructor instead.  */
+      tree ptr = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);
+
+      if (VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))
+	{
+	  /* Rewrite: `*(Array *)&vector'
+		into: `{ vector[0], vector[1], ... }'  */
+	  tree array = d_save_expr (TREE_OPERAND (ptr, 0));
+	  array = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expr), array);
+
+	  uinteger_t dim = ((TypeSArray *)tbtype)->dim->toUInteger ();
+	  vec <constructor_elt, va_gc> *elms = NULL;
+	  for (uinteger_t i = 0; i < dim; i++)
+	    {
+	      tree index = size_int (i);
+	      tree value = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (array)),
+				   array, index, NULL_TREE, NULL_TREE);
+	      CONSTRUCTOR_APPEND_ELT (elms, index, value);
+	    }
+
+	  return build_constructor (build_ctype (totype), elms);
+	}
+    }
+
   return result ? result : convert_expr (expr, etype, totype);
 }
 
@@ -694,7 +736,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)
       return expr;
     }
 
-  return convert_expr (expr, etype, totype);
+  return convert_for_rvalue (expr, etype, totype);
 }
 
 /* Return a TREE representation of EXPR converted to represent
--- a/src/gcc/d/decl.cc
+++ b/src/gcc/d/decl.cc
@@ -181,8 +181,16 @@ public:
 	    tree name = (alias != NULL)
 	      ? get_identifier (alias->toChars ()) : NULL_TREE;
 
-	    debug_hooks->imported_module_or_decl (decl, name, context,
-						  false, false);
+	    if (TREE_CODE (decl) != TREE_LIST)
+	      debug_hooks->imported_module_or_decl (decl, name, context,
+						    false, false);
+	    else
+	      {
+		/* Overload sets return a list of imported decls.  */
+		for (; decl != NULL_TREE; decl = TREE_CHAIN (decl))
+		  debug_hooks->imported_module_or_decl (TREE_VALUE (decl), name,
+							context, false, false);
+	      }
 	  }
       }
     else
--- a/src/gcc/d/dmd/expressionsem.c
+++ b/src/gcc/d/dmd/expressionsem.c
@@ -4309,6 +4309,7 @@ public:
         if (tob->ty == Tvector && t1b->ty != Tvector)
         {
             result = new VectorExp(exp->loc, exp->e1, exp->to);
+            result = semantic(result, sc);
             return;
         }
 
--- a/src/gcc/d/expr.cc
+++ b/src/gcc/d/expr.cc
@@ -2993,21 +2993,20 @@ public:
 
   void visit (VectorExp *e)
   {
-    tree type = build_ctype (e->type);
-    tree etype = TREE_TYPE (type);
-
     /* First handle array literal expressions.  */
     if (e->e1->op == TOKarrayliteral)
       {
 	ArrayLiteralExp *ale = ((ArrayLiteralExp *) e->e1);
 	vec<constructor_elt, va_gc> *elms = NULL;
 	bool constant_p = true;
+	tree type = build_ctype (e->type);
 
 	vec_safe_reserve (elms, ale->elements->dim);
 	for (size_t i = 0; i < ale->elements->dim; i++)
 	  {
 	    Expression *expr = ale->getElement (i);
-	    tree value = d_convert (etype, build_expr (expr, this->constp_));
+	    tree value = d_convert (TREE_TYPE (type),
+				    build_expr (expr, this->constp_));
 	    if (!CONSTANT_CLASS_P (value))
 	      constant_p = false;
 
@@ -3020,10 +3019,18 @@ public:
 	else
 	  this->result_ = build_constructor (type, elms);
       }
+    else if (e->e1->type->toBasetype ()->ty == Tsarray)
+      {
+	/* Build a vector representation from a static array.  */
+	this->result_ = convert_expr (build_expr (e->e1, this->constp_),
+				      e->e1->type, e->type);
+      }
     else
       {
 	/* Build constructor from single value.  */
-	tree val = d_convert (etype, build_expr (e->e1, this->constp_));
+	tree type = build_ctype (e->type);
+	tree val = d_convert (TREE_TYPE (type),
+			      build_expr (e->e1, this->constp_));
 	this->result_ = build_vector_from_val (type, val);
       }
   }
--- a/src/gcc/d/imports.cc
+++ b/src/gcc/d/imports.cc
@@ -157,6 +157,20 @@ public:
       }
   }
 
+  /* Build IMPORTED_DECLs for all overloads in a set.  */
+  void visit (OverloadSet *d)
+  {
+    vec<tree, va_gc> *tset = NULL;
+
+    vec_alloc (tset, d->a.dim);
+
+    for (size_t i = 0; i < d->a.dim; i++)
+      vec_safe_push (tset, build_import_decl (d->a[i]));
+
+    d->isym = build_tree_list_vec (tset);
+    tset->truncate (0);
+  }
+
   /* Function aliases are the same as alias symbols.  */
   void visit (FuncAliasDeclaration *d)
   {
--- a/src/gcc/d/toir.cc
+++ b/src/gcc/d/toir.cc
@@ -540,6 +540,28 @@ public:
     this->do_label (label);
   }
 
+  /* Generate and set a new continue label for the current unrolled loop.  */
+
+  void push_unrolled_continue_label (UnrolledLoopStatement *s)
+  {
+    this->push_continue_label (s);
+  }
+
+  /* Finish with the continue label for the unrolled loop.  */
+
+  void pop_unrolled_continue_label (UnrolledLoopStatement *s)
+  {
+    Statement *stmt = s->getRelatedLabeled ();
+    d_label_entry *ent = d_function_chain->labels->get (stmt);
+    gcc_assert (ent != NULL && ent->bc_label == true);
+
+    this->pop_continue_label (TREE_VEC_ELT (ent->label, bc_continue));
+
+    /* Remove the continue label from the label htab, as a new one must be
+       inserted at the end of every unrolled loop.  */
+    ent->label = TREE_VEC_ELT (ent->label, bc_break);
+  }
+
   /* Visitor interfaces.  */
 
 
@@ -1076,9 +1098,9 @@ public:
 
 	if (statement != NULL)
 	  {
-	    tree lcontinue = this->push_continue_label (statement);
+	    this->push_unrolled_continue_label (s);
 	    this->build_stmt (statement);
-	    this->pop_continue_label (lcontinue);
+	    this->pop_unrolled_continue_label (s);
 	  }
       }
 
--- a/src/gcc/expr.c
+++ b/src/gcc/expr.c
@@ -7282,8 +7282,7 @@ get_inner_reference (tree exp, poly_int64_pod *pbitsize,
 	  /* For vector fields re-check the target flags, as DECL_MODE
 	     could have been set with different target flags than
 	     the current function has.  */
-	  if (mode == BLKmode
-	      && VECTOR_TYPE_P (TREE_TYPE (field))
+	  if (VECTOR_TYPE_P (TREE_TYPE (field))
 	      && VECTOR_MODE_P (TYPE_MODE_RAW (TREE_TYPE (field))))
 	    mode = TYPE_MODE (TREE_TYPE (field));
 	}
--- a/src/gcc/fortran/ChangeLog
+++ b/src/gcc/fortran/ChangeLog
@@ -1,3 +1,239 @@
+2023-01-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108131
+	* array.c (match_array_element_spec): Avoid too early simplification
+	of matched array element specs that can lead to a misinterpretation
+	when used as array bounds in array declarations.
+
+2022-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/107872
+	* resolve.c (derived_inaccessible): Skip over allocatable components
+	to prevent an infinite loop.
+
+2022-11-25  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-11-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107576
+	* interface.c (gfc_procedure_use): Reject NULL as actual argument
+	when there is no explicit procedure interface.
+
+2022-10-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103413
+	* symbol.c (gfc_type_compatible): A boz-literal-constant has no type
+	and thus is not considered compatible to any type.
+
+2022-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-20  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105633
+	* expr.c (find_array_section): Move check for NULL pointers so
+	that both subscript triplets and vector subscripts are covered.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* trans-expr.c (gfc_conv_procedure_call): Collect all clobbers
+	to their own separate block.  Append the block of clobbers to
+	the procedure preliminary block after the argument evaluation
+	codes for all the arguments.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* trans-expr.c (gfc_conv_procedure_call): Retrieve variable
+	from the just calculated variable reference.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	* trans.h (gfc_conv_expr_reference): Remove add_clobber
+	argument.
+	* trans-expr.c (gfc_conv_expr_reference): Ditto. Inline code
+	depending on add_clobber and conditions controlling it ...
+	(gfc_conv_procedure_call): ... to here.
+
+2022-10-08  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100040
+	PR fortran/100029
+	* trans-expr.c (gfc_conv_class_to_class): Add code to have
+	assumed-rank arrays recognized as full arrays and fix the type
+	of the array assignment.
+	(gfc_conv_procedure_call): Change order of code blocks such that
+	the free of ALLOCATABLE dummy arguments with INTENT(OUT) occurs
+	first.
+
+2022-10-01  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* trans-types.c (create_fn_spec): Fix function attributes when
+	passing polymorphic pointers.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* simplify.c (gfc_simplify_unpack): Replace assert by condition
+	that terminates simplification when there are not enough elements
+	in the constructor of argument VECTOR.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* trans-decl.c (generate_coarray_sym_init): Skip symbol
+	if attr.associate_var.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* expr.c (gfc_simplify_expr): Avoid NULL pointer dereference.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* simplify.c (simplify_size): The size expression of an array cannot
+	be simplified if an error occurs while resolving the array spec.
+
+2022-09-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* simplify.c (gfc_simplify_findloc): Do not try to simplify
+	intrinsic FINDLOC when the ARRAY argument has a NULL shape.
+
+2022-09-24  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* trans-expr.c (trans_class_assignment): Add if clause to handle
+	derived type in the LHS.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* simplify.c (gfc_simplify_pack): Check for NULL pointer dereferences
+	while walking through constructors (error recovery).
+
+2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103504
+	* interface.c (get_sym_storage_size): Array bounds and character
+	length can only be of integer type.
+
+2022-07-16  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-07-15  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/104313
+	* trans-decl.c (gfc_generate_return): Do not generate conflicting
+	fake results for functions with no result variable under -ff2c.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-30  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103137
+	PR fortran/103138
+	PR fortran/103693
+	PR fortran/105243
+	* decl.c (gfc_match_data_decl): Reject CLASS entity declaration
+	when it is given the PARAMETER attribute.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-29  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106121
+	* simplify.c (gfc_simplify_extends_type_of): Do not attempt to
+	simplify when one of the arguments is a CLASS variable that was
+	not properly declared.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105954
+	* decl.c (variable_decl): Adjust upper bounds for explicit-shape
+	specs with constant bound expressions to ensure non-negative
+	extents.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105691
+	* simplify.c (gfc_simplify_index): Replace old simplification
+	code by the equivalent of the runtime library implementation.  Use
+	HOST_WIDE_INT instead of int for string index, length variables.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105813
+	* check.c (gfc_check_unpack): Try to simplify MASK argument to
+	UNPACK so that checking of the VECTOR argument can work when MASK
+	is a variable.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/gcc/fortran/array.c
+++ b/src/gcc/fortran/array.c
@@ -492,8 +492,6 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
-  gfc_try_simplify_expr (*upper, 0);
-
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
@@ -526,8 +524,6 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
-  gfc_try_simplify_expr (*upper, 0);
-
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
--- a/src/gcc/fortran/check.c
+++ b/src/gcc/fortran/check.c
@@ -6329,6 +6329,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
   if (!same_type_check (vector, 0, field, 2))
     return false;
 
+  gfc_simplify_expr (mask, 0);
+
   if (mask->expr_type == EXPR_ARRAY
       && gfc_array_size (vector, &vector_size))
     {
--- a/src/gcc/fortran/decl.c
+++ b/src/gcc/fortran/decl.c
@@ -2685,6 +2685,18 @@ variable_decl (int elem)
 		  else
 		    gfc_free_expr (n);
 		}
+	      /* For an explicit-shape spec with constant bounds, ensure
+		 that the effective upper bound is not lower than the
+		 respective lower bound minus one.  Otherwise adjust it so
+		 that the extent is trivially derived to be zero.  */
+	      if (as->lower[i]->expr_type == EXPR_CONSTANT
+		  && as->upper[i]->expr_type == EXPR_CONSTANT
+		  && as->lower[i]->ts.type == BT_INTEGER
+		  && as->upper[i]->ts.type == BT_INTEGER
+		  && mpz_cmp (as->upper[i]->value.integer,
+			      as->lower[i]->value.integer) < 0)
+		mpz_sub_ui (as->upper[i]->value.integer,
+			    as->lower[i]->value.integer, 1);
 	    }
 	}
     }
@@ -6169,6 +6181,14 @@ gfc_match_data_decl (void)
       goto cleanup;
     }
 
+  /* F2018:C708.  */
+  if (current_ts.type == BT_CLASS && current_attr.flavor == FL_PARAMETER)
+    {
+      gfc_error ("CLASS entity at %C cannot have the PARAMETER attribute");
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
   if (current_ts.type == BT_CLASS
 	&& current_ts.u.derived->attr.unlimited_polymorphic)
     goto ok;
--- a/src/gcc/fortran/expr.c
+++ b/src/gcc/fortran/expr.c
@@ -1549,6 +1549,12 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
       lower = ref->u.ar.as->lower[d];
       upper = ref->u.ar.as->upper[d];
 
+      if (!lower || !upper)
+	{
+	  t = false;
+	  goto cleanup;
+	}
+
       if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */
 	{
 	  gfc_constructor *ci;
@@ -1591,9 +1597,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
 	{
 	  if ((begin && begin->expr_type != EXPR_CONSTANT)
 	      || (finish && finish->expr_type != EXPR_CONSTANT)
-	      || (step && step->expr_type != EXPR_CONSTANT)
-	      || !lower
-	      || !upper)
+	      || (step && step->expr_type != EXPR_CONSTANT))
 	    {
 	      t = false;
 	      goto cleanup;
@@ -2277,7 +2281,8 @@ gfc_simplify_expr (gfc_expr *p, int type)
 	 initialization expression, or we want a subsection.  */
       if (p->symtree->n.sym->attr.flavor == FL_PARAMETER
 	  && (gfc_init_expr_flag || p->ref
-	      || p->symtree->n.sym->value->expr_type != EXPR_ARRAY))
+	      || (p->symtree->n.sym->value
+		  && p->symtree->n.sym->value->expr_type != EXPR_ARRAY)))
 	{
 	  if (!simplify_parameter_variable (p, type))
 	    return false;
--- a/src/gcc/fortran/interface.c
+++ b/src/gcc/fortran/interface.c
@@ -2759,7 +2759,8 @@ get_sym_storage_size (gfc_symbol *sym)
   if (sym->ts.type == BT_CHARACTER)
     {
       if (sym->ts.u.cl && sym->ts.u.cl->length
-          && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
+	  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	  && sym->ts.u.cl->length->ts.type == BT_INTEGER)
 	strlen = mpz_get_ui (sym->ts.u.cl->length->value.integer);
       else
 	return 0;
@@ -2776,7 +2777,9 @@ get_sym_storage_size (gfc_symbol *sym)
   for (i = 0; i < sym->as->rank; i++)
     {
       if (sym->as->upper[i]->expr_type != EXPR_CONSTANT
-	  || sym->as->lower[i]->expr_type != EXPR_CONSTANT)
+	  || sym->as->lower[i]->expr_type != EXPR_CONSTANT
+	  || sym->as->upper[i]->ts.type != BT_INTEGER
+	  || sym->as->lower[i]->ts.type != BT_INTEGER)
 	return 0;
 
       elements *= mpz_get_si (sym->as->upper[i]->value.integer)
@@ -3965,6 +3968,14 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 	      return false;
 	    }
 
+	  if (a->expr && a->expr->expr_type == EXPR_NULL)
+	    {
+	      gfc_error ("Passing intrinsic NULL as actual argument at %L "
+			 "requires an explicit interface", &a->expr->where);
+	      a->expr->error = 1;
+	      return false;
+	    }
+
 	  /* TS 29113, C407b.  */
 	  if (a->expr && a->expr->expr_type == EXPR_VARIABLE
 	      && symbol_rank (a->expr->symtree->n.sym) == -1)
--- a/src/gcc/fortran/resolve.c
+++ b/src/gcc/fortran/resolve.c
@@ -7440,7 +7440,8 @@ derived_inaccessible (gfc_symbol *sym)
   for (c = sym->components; c; c = c->next)
     {
 	/* Prevent an infinite loop through this function.  */
-	if (c->ts.type == BT_DERIVED && c->attr.pointer
+	if (c->ts.type == BT_DERIVED
+	    && (c->attr.pointer || c->attr.allocatable)
 	    && sym == c->ts.u.derived)
 	  continue;
 
--- a/src/gcc/fortran/simplify.c
+++ b/src/gcc/fortran/simplify.c
@@ -3060,6 +3060,10 @@ gfc_simplify_extends_type_of (gfc_expr *a, gfc_expr *mold)
   if (UNLIMITED_POLY (a) || UNLIMITED_POLY (mold))
     return NULL;
 
+  if ((a->ts.type == BT_CLASS && !gfc_expr_attr (a).class_ok)
+      || (mold->ts.type == BT_CLASS && !gfc_expr_attr (mold).class_ok))
+    return NULL;
+
   /* Return .false. if the dynamic type can never be an extension.  */
   if ((a->ts.type == BT_CLASS && mold->ts.type == BT_CLASS
        && !gfc_type_is_extension_of
@@ -3470,17 +3474,15 @@ gfc_expr *
 gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)
 {
   gfc_expr *result;
-  int back, len, lensub;
-  int i, j, k, count, index = 0, start;
+  bool back;
+  HOST_WIDE_INT len, lensub, start, last, i, index = 0;
+  int k, delta;
 
   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT
       || ( b != NULL && b->expr_type !=  EXPR_CONSTANT))
     return NULL;
 
-  if (b != NULL && b->value.logical != 0)
-    back = 1;
-  else
-    back = 0;
+  back = (b != NULL && b->value.logical != 0);
 
   k = get_kind (BT_INTEGER, kind, "INDEX", gfc_default_integer_kind);
   if (k == -1)
@@ -3497,111 +3499,40 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)
       return result;
     }
 
-  if (back == 0)
+  if (lensub == 0)
     {
-      if (lensub == 0)
-	{
-	  mpz_set_si (result->value.integer, 1);
-	  return result;
-	}
-      else if (lensub == 1)
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[i])
-		    {
-		      index = i + 1;
-		      goto done;
-		    }
-		}
-	    }
-	}
+      if (back)
+	index = len + 1;
       else
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[i])
-		    {
-		      start = i;
-		      count = 0;
-
-		      for (k = 0; k < lensub; k++)
-			{
-			  if (y->value.character.string[k]
-			      == x->value.character.string[k + start])
-			    count++;
-			}
-
-		      if (count == lensub)
-			{
-			  index = start + 1;
-			  goto done;
-			}
-		    }
-		}
-	    }
-	}
+	index = 1;
+      goto done;
+    }
 
+  if (!back)
+    {
+      last = len + 1 - lensub;
+      start = 0;
+      delta = 1;
     }
   else
     {
-      if (lensub == 0)
-	{
-	  mpz_set_si (result->value.integer, len + 1);
-	  return result;
-	}
-      else if (lensub == 1)
+      last = -1;
+      start = len - lensub;
+      delta = -1;
+    }
+
+  for (; start != last; start += delta)
+    {
+      for (i = 0; i < lensub; i++)
 	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[len - i])
-		    {
-		      index = len - i + 1;
-		      goto done;
-		    }
-		}
-	    }
+	  if (x->value.character.string[start + i]
+	      != y->value.character.string[i])
+	    break;
 	}
-      else
+      if (i == lensub)
 	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[len - i])
-		    {
-		      start = len - i;
-		      if (start <= len - lensub)
-			{
-			  count = 0;
-			  for (k = 0; k < lensub; k++)
-			    if (y->value.character.string[k]
-			        == x->value.character.string[k + start])
-			      count++;
-
-			  if (count == lensub)
-			    {
-			      index = start + 1;
-			      goto done;
-			    }
-			}
-		      else
-			{
-			  continue;
-			}
-		    }
-		}
-	    }
+	  index = start + 1;
+	  goto done;
 	}
     }
 
@@ -5826,6 +5757,7 @@ gfc_simplify_findloc (gfc_expr *array, gfc_expr *value, gfc_expr *dim,
   bool back_val = false;
 
   if (!is_constant_array_expr (array)
+      || array->shape == NULL
       || !gfc_is_constant_expr (dim))
     return NULL;
 
@@ -6362,7 +6294,7 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)
       /* Copy only those elements of ARRAY to RESULT whose
 	 MASK equals .TRUE..  */
       mask_ctor = gfc_constructor_first (mask->value.constructor);
-      while (mask_ctor)
+      while (mask_ctor && array_ctor)
 	{
 	  if (mask_ctor->expr->value.logical)
 	    {
@@ -7455,8 +7387,9 @@ simplify_size (gfc_expr *array, gfc_expr *dim, int k)
     }
 
   for (ref = array->ref; ref; ref = ref->next)
-    if (ref->type == REF_ARRAY && ref->u.ar.as)
-      gfc_resolve_array_spec (ref->u.ar.as, 0);
+    if (ref->type == REF_ARRAY && ref->u.ar.as
+	&& !gfc_resolve_array_spec (ref->u.ar.as, 0))
+      return NULL;
 
   if (dim == NULL)
     {
@@ -8375,9 +8308,16 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
     {
       if (mask_ctor->expr->value.logical)
 	{
-	  gcc_assert (vector_ctor);
-	  e = gfc_copy_expr (vector_ctor->expr);
-	  vector_ctor = gfc_constructor_next (vector_ctor);
+	  if (vector_ctor)
+	    {
+	      e = gfc_copy_expr (vector_ctor->expr);
+	      vector_ctor = gfc_constructor_next (vector_ctor);
+	    }
+	  else
+	    {
+	      gfc_free_expr (result);
+	      return NULL;
+	    }
 	}
       else if (field->expr_type == EXPR_ARRAY)
 	e = gfc_copy_expr (field_ctor->expr);
--- a/src/gcc/fortran/symbol.c
+++ b/src/gcc/fortran/symbol.c
@@ -5123,6 +5123,10 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)
   bool is_union1 = (ts1->type == BT_UNION);
   bool is_union2 = (ts2->type == BT_UNION);
 
+  /* A boz-literal-constant has no type.  */
+  if (ts1->type == BT_BOZ || ts2->type == BT_BOZ)
+    return false;
+
   if (is_class1
       && ts1->u.derived->components
       && ((ts1->u.derived->attr.is_class
--- a/src/gcc/fortran/trans-decl.c
+++ b/src/gcc/fortran/trans-decl.c
@@ -5605,6 +5605,7 @@ generate_coarray_sym_init (gfc_symbol *sym)
 
   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension
       || sym->attr.use_assoc || !sym->attr.referenced
+      || sym->attr.associate_var
       || sym->attr.select_type_temporary)
     return;
 
@@ -6545,7 +6546,7 @@ gfc_generate_return (void)
 	     NULL_TREE, and a 'return' is generated without a variable.
 	     The following generates a 'return __result_XXX' where XXX is
 	     the function name.  */
-	  if (sym == sym->result && sym->attr.function)
+	  if (sym == sym->result && sym->attr.function && !flag_f2c)
 	    {
 	      result = gfc_get_fake_result_decl (sym, 0);
 	      result = fold_build2_loc (input_location, MODIFY_EXPR,
--- a/src/gcc/fortran/trans-expr.c
+++ b/src/gcc/fortran/trans-expr.c
@@ -1084,8 +1084,10 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
     return;
 
   /* Test for FULL_ARRAY.  */
-  if (e->rank == 0 && gfc_expr_attr (e).codimension
-      && gfc_expr_attr (e).dimension)
+  if (e->rank == 0
+      && ((gfc_expr_attr (e).codimension && gfc_expr_attr (e).dimension)
+	  || (class_ts.u.derived->components->as
+	      && class_ts.u.derived->components->as->type == AS_ASSUMED_RANK)))
     full_array = true;
   else
     gfc_is_class_array_ref (e, &full_array);
@@ -1133,8 +1135,12 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
 	  && e->rank != class_ts.u.derived->components->as->rank)
 	{
 	  if (e->rank == 0)
-	    gfc_add_modify (&parmse->post, gfc_class_data_get (parmse->expr),
-			    gfc_conv_descriptor_data_get (ctree));
+	    {
+	      tmp = gfc_class_data_get (parmse->expr);
+	      gfc_add_modify (&parmse->post, tmp,
+			      fold_convert (TREE_TYPE (tmp),
+					 gfc_conv_descriptor_data_get (ctree)));
+	    }
 	  else
 	    class_array_data_assign (&parmse->post, parmse->expr, ctree, true);
 	}
@@ -5586,7 +5592,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   gfc_charlen cl;
   gfc_expr *e;
   gfc_symbol *fsym;
-  stmtblock_t post;
   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};
   gfc_component *comp = NULL;
   int arglen;
@@ -5630,7 +5635,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   else
     info = NULL;
 
+  stmtblock_t post, clobbers;
   gfc_init_block (&post);
+  gfc_init_block (&clobbers);
   gfc_init_interface_mapping (&mapping);
   if (!comp)
     {
@@ -5965,7 +5972,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				&& e->symtree->n.sym->attr.pointer))
 			&& fsym && fsym->attr.target)
 		/* Make sure the function only gets called once.  */
-		gfc_conv_expr_reference (&parmse, e, false);
+		gfc_conv_expr_reference (&parmse, e);
 	      else if (e->expr_type == EXPR_FUNCTION
 		       && e->symtree->n.sym->result
 		       && e->symtree->n.sym->result != e->symtree->n.sym
@@ -6072,22 +6079,37 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    }
 		  else
 		    {
-		      bool add_clobber;
-		      add_clobber = fsym && fsym->attr.intent == INTENT_OUT
-			&& !fsym->attr.allocatable && !fsym->attr.pointer
-			&& e->symtree && e->symtree->n.sym
-			&& !e->symtree->n.sym->attr.dimension
-			&& !e->symtree->n.sym->attr.pointer
-			&& !e->symtree->n.sym->attr.allocatable
-			/* See PR 41453.  */
-			&& !e->symtree->n.sym->attr.dummy
-			/* FIXME - PR 87395 and PR 41453  */
-			&& e->symtree->n.sym->attr.save == SAVE_NONE
-			&& !e->symtree->n.sym->attr.associate_var
-			&& e->ts.type != BT_CHARACTER && e->ts.type != BT_DERIVED
-			&& e->ts.type != BT_CLASS && !sym->attr.elemental;
-
-		      gfc_conv_expr_reference (&parmse, e, add_clobber);
+		      gfc_conv_expr_reference (&parmse, e);
+
+		      if (fsym
+			  && fsym->attr.intent == INTENT_OUT
+			  && !fsym->attr.allocatable
+			  && !fsym->attr.pointer
+			  && e->expr_type == EXPR_VARIABLE
+			  && e->ref == NULL
+			  && e->symtree
+			  && e->symtree->n.sym
+			  && !e->symtree->n.sym->attr.dimension
+			  && !e->symtree->n.sym->attr.pointer
+			  && !e->symtree->n.sym->attr.allocatable
+			  /* See PR 41453.  */
+			  && !e->symtree->n.sym->attr.dummy
+			  /* FIXME - PR 87395 and PR 41453  */
+			  && e->symtree->n.sym->attr.save == SAVE_NONE
+			  && !e->symtree->n.sym->attr.associate_var
+			  && e->ts.type != BT_CHARACTER
+			  && e->ts.type != BT_DERIVED
+			  && e->ts.type != BT_CLASS
+			  && !sym->attr.elemental)
+			{
+			  tree var;
+			  /* FIXME: This fails if var is passed by reference, see PR
+			     41453.  */
+			  var = build_fold_indirect_ref_loc (input_location,
+							     parmse.expr);
+			  tree clobber = build_clobber (TREE_TYPE (var));
+			  gfc_add_modify (&clobbers, var, clobber);
+			}
 		    }
 		  /* Catch base objects that are not variables.  */
 		  if (e->ts.type == BT_CLASS
@@ -6096,23 +6118,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    base_object = build_fold_indirect_ref_loc (input_location,
 							       parmse.expr);
 
-		  /* A class array element needs converting back to be a
-		     class object, if the formal argument is a class object.  */
-		  if (fsym && fsym->ts.type == BT_CLASS
-			&& e->ts.type == BT_CLASS
-			&& ((CLASS_DATA (fsym)->as
-			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
-			    || CLASS_DATA (e)->attr.dimension))
-		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
-				     fsym->attr.intent != INTENT_IN
-				     && (CLASS_DATA (fsym)->attr.class_pointer
-					 || CLASS_DATA (fsym)->attr.allocatable),
-				     fsym->attr.optional
-				     && e->expr_type == EXPR_VARIABLE
-				     && e->symtree->n.sym->attr.optional,
-				     CLASS_DATA (fsym)->attr.class_pointer
-				     || CLASS_DATA (fsym)->attr.allocatable);
-
 		  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is
 		     allocated on entry, it must be deallocated.  */
 		  if (fsym && fsym->attr.intent == INTENT_OUT
@@ -6172,6 +6177,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		    }
 
+		  /* A class array element needs converting back to be a
+		     class object, if the formal argument is a class object.  */
+		  if (fsym && fsym->ts.type == BT_CLASS
+			&& e->ts.type == BT_CLASS
+			&& ((CLASS_DATA (fsym)->as
+			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
+			    || CLASS_DATA (e)->attr.dimension))
+		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
+				     fsym->attr.intent != INTENT_IN
+				     && (CLASS_DATA (fsym)->attr.class_pointer
+					 || CLASS_DATA (fsym)->attr.allocatable),
+				     fsym->attr.optional
+				     && e->expr_type == EXPR_VARIABLE
+				     && e->symtree->n.sym->attr.optional,
+				     CLASS_DATA (fsym)->attr.class_pointer
+				     || CLASS_DATA (fsym)->attr.allocatable);
+
 		  if (fsym && (fsym->ts.type == BT_DERIVED
 			       || fsym->ts.type == BT_ASSUMED)
 		      && e->ts.type == BT_CLASS
@@ -6855,6 +6877,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
       vec_safe_push (arglist, parmse.expr);
     }
+  gfc_add_block_to_block (&se->pre, &clobbers);
   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);
 
   if (comp)
@@ -8948,7 +8971,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)
    values only.  */
 
 void
-gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
+gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)
 {
   gfc_ss *ss;
   tree var;
@@ -8988,16 +9011,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
 	  gfc_add_block_to_block (&se->pre, &se->post);
 	  se->expr = var;
 	}
-      else if (add_clobber && expr->ref == NULL)
-	{
-	  tree clobber;
-	  tree var;
-	  /* FIXME: This fails if var is passed by reference, see PR
-	     41453.  */
-	  var = expr->symtree->n.sym->backend_decl;
-	  clobber = build_clobber (TREE_TYPE (var));
-	  gfc_add_modify (&se->pre, var, clobber);
-	}
       return;
     }
 
@@ -10904,6 +10917,9 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,
       class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))
 	  ? gfc_class_data_get (lse->expr) : lse->expr;
 
+      if (!POINTER_TYPE_P (TREE_TYPE (class_han)))
+	class_han = gfc_build_addr_expr (NULL_TREE, class_han);
+
       /* Allocate block.  */
       gfc_init_block (&alloc);
       gfc_allocate_using_malloc (&alloc, class_han, size, NULL_TREE);
--- a/src/gcc/fortran/trans-types.c
+++ b/src/gcc/fortran/trans-types.c
@@ -2954,12 +2954,23 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
     if (spec_len < sizeof (spec))
       {
-	if (!f->sym || f->sym->attr.pointer || f->sym->attr.target
+	bool is_class = false;
+	bool is_pointer = false;
+
+	if (f->sym)
+	  {
+	    is_class = f->sym->ts.type == BT_CLASS && CLASS_DATA (f->sym)
+	      && f->sym->attr.class_ok;
+	    is_pointer = is_class ? CLASS_DATA (f->sym)->attr.class_pointer
+				  : f->sym->attr.pointer;
+	  }
+
+	if (f->sym == NULL || is_pointer || f->sym->attr.target
 	    || f->sym->attr.external || f->sym->attr.cray_pointer
 	    || (f->sym->ts.type == BT_DERIVED
 		&& (f->sym->ts.u.derived->attr.proc_pointer_comp
 		    || f->sym->ts.u.derived->attr.pointer_comp))
-	    || (f->sym->ts.type == BT_CLASS
+	    || (is_class
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
 		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
--- a/src/gcc/fortran/trans.h
+++ b/src/gcc/fortran/trans.h
@@ -499,8 +499,7 @@ tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);
 void gfc_conv_expr (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_val (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);
-void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr,
-			      bool add_clobber = false);
+void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);
 
 
--- a/src/gcc/gcc.c
+++ b/src/gcc/gcc.c
@@ -27,6 +27,7 @@ CC recognizes how to compile each input file by suffixes in the file names.
 Once it knows which kind of compilation to perform, the procedure for
 compilation is specified by a string called a "spec".  */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -43,6 +44,7 @@ compilation is specified by a string called a "spec".  */
 #include "opts.h"
 #include "filenames.h"
 #include "spellcheck.h"
+#include "opts-jobserver.h"
 
 
 
@@ -8399,38 +8401,9 @@ driver::final_actions () const
 void
 driver::detect_jobserver () const
 {
-  /* Detect jobserver and drop it if it's not working.  */
-  const char *makeflags = env.get ("MAKEFLAGS");
-  if (makeflags != NULL)
-    {
-      const char *needle = "--jobserver-auth=";
-      const char *n = strstr (makeflags, needle);
-      if (n != NULL)
-	{
-	  int rfd = -1;
-	  int wfd = -1;
-
-	  bool jobserver
-	    = (sscanf (n + strlen (needle), "%d,%d", &rfd, &wfd) == 2
-	       && rfd > 0
-	       && wfd > 0
-	       && is_valid_fd (rfd)
-	       && is_valid_fd (wfd));
-
-	  /* Drop the jobserver if it's not working now.  */
-	  if (!jobserver)
-	    {
-	      unsigned offset = n - makeflags;
-	      char *dup = xstrdup (makeflags);
-	      dup[offset] = '\0';
-
-	      const char *space = strchr (makeflags + offset, ' ');
-	      if (space != NULL)
-		strcpy (dup + offset, space);
-	      xputenv (concat ("MAKEFLAGS=", dup, NULL));
-	    }
-	}
-    }
+  jobserver_info jinfo;
+  if (!jinfo.is_active && !jinfo.skipped_makeflags.empty ())
+    xputenv (jinfo.skipped_makeflags.c_str ());
 }
 
 /* Determine what the exit code of the driver should be.  */
--- a/src/gcc/gimple-ssa-store-merging.c
+++ b/src/gcc/gimple-ssa-store-merging.c
@@ -263,7 +263,7 @@ do_shift_rotate (enum tree_code code,
 		 int count)
 {
   int i, size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;
-  unsigned head_marker;
+  uint64_t head_marker;
 
   if (count < 0
       || count >= TYPE_PRECISION (n->type)
--- a/src/gcc/ira-color.c
+++ b/src/gcc/ira-color.c
@@ -1956,8 +1956,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)
     restore_costs_from_copies (a);
   ALLOCNO_HARD_REGNO (a) = best_hard_regno;
   ALLOCNO_ASSIGNED_P (a) = true;
-  if (best_hard_regno >= 0)
-    update_costs_from_copies (a, true, ! retry_p);
+  if (best_hard_regno >= 0 && !retry_p)
+    update_costs_from_copies (a, true, true);
   ira_assert (ALLOCNO_CLASS (a) == aclass);
   /* We don't need updated costs anymore.  */
   ira_free_allocno_updated_costs (a);
--- a/src/gcc/lto-streamer-in.c
+++ b/src/gcc/lto-streamer-in.c
@@ -1689,11 +1689,14 @@ lto_read_tree_1 (class lto_input_block *ib, class data_in *data_in, tree expr)
   /* Read all the pointer fields in EXPR.  */
   streamer_read_tree_body (ib, data_in, expr);
 
-  /* Read any LTO-specific data not read by the tree streamer.  */
+  /* Read any LTO-specific data not read by the tree streamer.  Do not use
+     stream_read_tree here since that flushes the dref_queue in mids of
+     SCC reading.  */
   if (DECL_P (expr)
       && TREE_CODE (expr) != FUNCTION_DECL
       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)
-    DECL_INITIAL (expr) = stream_read_tree (ib, data_in);
+    DECL_INITIAL (expr)
+      = lto_input_tree_1 (ib, data_in, streamer_read_record_start (ib), 0);
 
   /* Stream references to early generated DIEs.  Keep in sync with the
      trees handled in dwarf2out_register_external_die.  */
--- a/src/gcc/lto-wrapper.c
+++ b/src/gcc/lto-wrapper.c
@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see
    ./ccCJuXGv.lto.ltrans.o
 */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -48,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "simple-object.h"
 #include "lto-section-names.h"
 #include "collect-utils.h"
+#include "opts-jobserver.h"
 
 /* Environment variable, used for passing the names of offload targets from GCC
    driver to lto-wrapper.  */
@@ -1295,32 +1297,6 @@ init_num_threads (void)
 #endif
 }
 
-/* FIXME: once using -std=c++11, we can use std::thread::hardware_concurrency.  */
-
-/* Return true when a jobserver is running and can accept a job.  */
-
-static bool
-jobserver_active_p (void)
-{
-  const char *makeflags = getenv ("MAKEFLAGS");
-  if (makeflags == NULL)
-    return false;
-
-  const char *needle = "--jobserver-auth=";
-  const char *n = strstr (makeflags, needle);
-  if (n == NULL)
-    return false;
-
-  int rfd = -1;
-  int wfd = -1;
-
-  return (sscanf (n + strlen (needle), "%d,%d", &rfd, &wfd) == 2
-	  && rfd > 0
-	  && wfd > 0
-	  && is_valid_fd (rfd)
-	  && is_valid_fd (wfd));
-}
-
 /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */
 
 static void
@@ -1535,10 +1511,20 @@ run_gcc (unsigned argc, char *argv[])
       auto_parallel = 0;
       parallel = 0;
     }
-  else if (!jobserver && jobserver_active_p ())
+  else
     {
-      parallel = 1;
-      jobserver = 1;
+      jobserver_info jinfo;
+      if (jobserver && !jinfo.is_active)
+	{
+	  warning (0, jinfo.error_msg.c_str ());
+	  parallel = 0;
+	  jobserver = 0;
+	}
+      else if (!jobserver && jinfo.is_active)
+	{
+	  parallel = 1;
+	  jobserver = 1;
+	}
     }
 
   if (linker_output)
@@ -1861,6 +1847,15 @@ cont:
       maybe_unlink (ltrans_output_file);
       ltrans_output_file = NULL;
 
+      if (nr > 1)
+	{
+	  jobserver_info jinfo;
+	  if (jobserver && !jinfo.is_active)
+	    warning (0, jinfo.error_msg.c_str ());
+	  else if (parallel == 0)
+	    warning (0, "using serial compilation of %d LTRANS jobs", nr);
+	}
+
       if (parallel)
 	{
 	  makefile = make_temp_file (".mk");
--- a/src/gcc/optabs.c
+++ b/src/gcc/optabs.c
@@ -5902,6 +5902,14 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,
 			   GET_MODE_NUNITS (cmp_op_mode)));
 
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
+  /* Some targets do not have vcondeq and only vcond with NE/EQ
+     but not vcondu, so make sure to also try vcond here as
+     vcond_icode_p would canonicalize the optab query to.  */
+  if (icode == CODE_FOR_nothing
+      && (tcode == NE_EXPR || tcode == EQ_EXPR)
+      && ((icode = get_vcond_icode (mode, cmp_op_mode, !unsignedp))
+	  != CODE_FOR_nothing))
+    unsignedp = !unsignedp;
   if (icode == CODE_FOR_nothing)
     {
       if (tcode == LT_EXPR
--- a/src/gcc/opts-common.c
+++ b/src/gcc/opts-common.c
@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "intl.h"
@@ -25,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "options.h"
 #include "diagnostic.h"
 #include "spellcheck.h"
+#include "opts-jobserver.h"
 
 static void prune_options (struct cl_decoded_option **, unsigned int *);
 
@@ -1805,3 +1807,55 @@ void prepend_xassembler_to_collect_as_options (const char *collect_as_options,
       obstack_1grow (o, '\'');
     }
 }
+
+jobserver_info::jobserver_info ()
+{
+  /* Traditionally, GNU make uses opened pipes for jobserver-auth,
+    e.g. --jobserver-auth=3,4.
+    Starting with GNU make 4.4, one can use --jobserver-style=fifo
+    and then named pipe is used: --jobserver-auth=fifo:/tmp/hcsparta.  */
+
+  /* Detect jobserver and drop it if it's not working.  */
+  string js_needle = "--jobserver-auth=";
+  string fifo_prefix = "fifo:";
+
+  const char *envval = getenv ("MAKEFLAGS");
+  if (envval != NULL)
+    {
+      string makeflags = envval;
+      size_t n = makeflags.rfind (js_needle);
+      if (n != string::npos)
+	{
+	  string ending = makeflags.substr (n + js_needle.size ());
+	  if (ending.find (fifo_prefix) == 0)
+	    {
+	      ending = ending.substr (fifo_prefix.size ());
+	      pipe_path = ending.substr (0, ending.find (' '));
+	      is_active = true;
+	    }
+	  else if (sscanf (makeflags.c_str () + n + js_needle.size (),
+			   "%d,%d", &rfd, &wfd) == 2
+	      && rfd > 0
+	      && wfd > 0
+	      && is_valid_fd (rfd)
+	      && is_valid_fd (wfd))
+	    is_active = true;
+	  else
+	    {
+	      string dup = makeflags.substr (0, n);
+	      size_t pos = makeflags.find (' ', n);
+	      if (pos != string::npos)
+		dup += makeflags.substr (pos);
+	      skipped_makeflags = "MAKEFLAGS=" + dup;
+	      error_msg
+		= "cannot access %<" + js_needle + "%> file descriptors";
+	    }
+	}
+      error_msg = "%<" + js_needle + "%> is not present in %<MAKEFLAGS%>";
+    }
+  else
+    error_msg = "%<MAKEFLAGS%> environment variable is unset";
+
+  if (!error_msg.empty ())
+    error_msg = "jobserver is not available: " + error_msg;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/opts-jobserver.h
@@ -0,0 +1,46 @@
+/* GNU make's jobserver related functionality.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.
+
+See dbgcnt.def for usage information.  */
+
+#ifndef GCC_JOBSERVER_H
+#define GCC_JOBSERVER_H
+
+using namespace std;
+
+struct jobserver_info
+{
+  /* Default constructor.  */
+  jobserver_info ();
+
+  /* Error message if there is a problem.  */
+  string error_msg = "";
+  /* Skipped MAKEFLAGS where --jobserver-auth is skipped.  */
+  string skipped_makeflags = "";
+  /* File descriptor for reading used for jobserver communication.  */
+  int rfd = -1;
+  /* File descriptor for writing used for jobserver communication.  */
+  int wfd = -1;
+  /* Named pipe path.  */
+  string pipe_path = "";
+  /* Return true if jobserver is active.  */
+  bool is_active = false;
+};
+
+#endif /* GCC_JOBSERVER_H */
--- a/src/gcc/regrename.c
+++ b/src/gcc/regrename.c
@@ -324,8 +324,7 @@ static bool
 check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,
 		 class du_head *this_head, HARD_REG_SET this_unavailable)
 {
-  machine_mode mode = GET_MODE (*this_head->first->loc);
-  int nregs = hard_regno_nregs (new_reg, mode);
+  int nregs = this_head->nregs;
   int i;
   struct du_chain *tmp;
 
--- a/src/gcc/testsuite/ChangeLog
+++ b/src/gcc/testsuite/ChangeLog
@@ -1,3 +1,488 @@
+2023-01-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108131
+	* gfortran.dg/pr103505.f90: Adjust expected patterns.
+	* gfortran.dg/pr108131.f90: New test.
+
+2023-01-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	Backported from master:
+	2021-12-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR testsuite/47334
+	PR testsuite/103823
+	* lib/prune.exp: Prune some warnings related to LTO and
+	visibility.
+
+2023-01-06  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-05-12  Martin Liska  <mliska@suse.cz>
+
+	* lib/lto.exp: When running tests without jobserver, one can see
+	the following warning for tests that use 1to1 partitioning.
+
+2023-01-05  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106736
+	* gcc.target/powerpc/pr106736-1.c: New test.
+	* gcc.target/powerpc/pr106736-2.c: Likewise.
+	* gcc.target/powerpc/pr106736-3.c: Likewise.
+	* gcc.target/powerpc/pr106736-4.c: Likewise.
+	* gcc.target/powerpc/pr106736-5.c: Likewise.
+
+2022-12-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* g++.dg/guality/guality.exp: Skip on hppa*-*-hpux*.
+	* gcc.dg/guality/guality.exp: Likewise.
+	* gfortran.dg/guality/guality.exp: Likewise.
+
+2022-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/107872
+	* gfortran.dg/pr107872.f90: New test.
+
+2022-12-16  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-10-28  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102780
+	PR c++/108138
+	* g++.dg/cpp1z/fold13.C: New test.
+
+2022-12-15  Sebastian Pop  <spop@amazon.com>
+
+	PR target/98776
+	* gcc.target/aarch64/pr98776.c: New.
+	* gcc.target/aarch64/pr92424-2.c: Adjust pattern.
+	* gcc.target/aarch64/pr92424-3.c: Adjust pattern.
+
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108050
+	* gdc.dg/imports/pr108050/mod1.d: New.
+	* gdc.dg/imports/pr108050/mod2.d: New.
+	* gdc.dg/imports/pr108050/package.d: New.
+	* gdc.dg/pr108050.d: New test.
+
+2022-12-01  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/pr107863.c: New test.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/107592
+	* gdc.dg/pr107592.d: New test.
+
+2022-11-25  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-11-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107576
+	* gfortran.dg/null_actual_3.f90: New test.
+
+2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/104066
+	* g++.dg/cpp2a/constinit18.C: New test.
+
+2022-11-08  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-10-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107304
+	* gcc.target/i386/pr107304.c: New test.
+
+2022-10-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103413
+	* gfortran.dg/illegal_boz_arg_4.f90: New test.
+
+2022-10-25  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2022-10-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/pr106355.h: Common code for new tests.
+	* gcc.target/s390/pr106355-1.c: New test.
+	* gcc.target/s390/pr106355-2.c: New test.
+	* gcc.target/s390/pr106355-3.c: New test.
+
+2022-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-20  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105633
+	* gfortran.dg/pr105633.f90: New test.
+
+2022-10-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/acle/general/brka_1.c: Expect a separate
+	PTEST instruction.
+	* gcc.target/aarch64/sve/acle/general/brkb_1.c: Likewise.
+
+2022-10-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/acle/general/brkn_1.c: Expect separate
+	PTEST instructions.
+	* gcc.target/aarch64/sve/acle/general/brkn_2.c: New test.
+
+2022-10-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/pragma_cpp_predefs_1.c: Add RCPC tests.
+
+2022-10-20  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96072
+	* gcc.target/powerpc/pr96072.c: New test.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106513
+	* gcc.dg/torture/pr106513.c: New testcase.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/106331
+	* gfortran.dg/pr106331.f90: New testcase.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106131
+	* g++.dg/torture/pr106131.C: New testcase.
+
+2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-06-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106112
+	* gcc.dg/torture/pr106112.c: New testcase.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* gfortran.dg/intent_optimize_4.f90: New test.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* gfortran.dg/intent_out_15.f90: New test.
+
+2022-10-08  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100029
+	PR fortran/100040
+	* gfortran.dg/PR100029.f90: New test.
+	* gfortran.dg/PR100040.f90: New test.
+
+2022-10-01  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* gfortran.dg/PR100132.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* gfortran.dg/pr107054.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* gfortran.dg/associate_26a.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* gfortran.dg/pr106985.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* gfortran.dg/pr103694.f90: New test.
+
+2022-09-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* gfortran.dg/pr106986.f90: New test.
+
+2022-09-24  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  Jos Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* gfortran.dg/PR100245.f90: New test.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* gfortran.dg/pr106857.f90: New test.
+
+2022-09-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* g++.target/powerpc/pr101322.C: New test.
+
+2022-09-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-07  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* lib/target-supports.exp (check_effective_target_has_arch_pwr5): Add
+	a function definition to avoid pedwarn about empty translation unit.
+	(check_effective_target_has_arch_pwr6): Likewise.
+	(check_effective_target_has_arch_pwr7): Likewise.
+	(check_effective_target_has_arch_pwr8): Likewise.
+	(check_effective_target_has_arch_pwr9): Likewise.
+	(check_effective_target_has_arch_ppc64): Likewise.
+	(check_effective_target_ppc_float128): Likewise.
+	(check_effective_target_ppc_float128_insns): Likewise.
+	(check_effective_target_powerpc_vsx): Likewise.
+
+2022-08-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* gcc.target/powerpc/pr106017.c: New test.
+
+2022-08-24  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-08-16  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/103353
+	* gcc.target/powerpc/pr103353.c: New test.
+
+2022-08-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-26  Segher Boessenkoool  <segher@kernel.crashing.org>
+
+	PR target/105349
+	* lib/target-supports.exp (check_effective_target_has_arch_pwr5): Use
+	the specified dg-options.
+	(check_effective_target_has_arch_pwr6): Ditto.
+	(check_effective_target_has_arch_pwr7): Ditto.
+	(check_effective_target_has_arch_pwr8): Ditto.
+	(check_effective_target_has_arch_pwr9): Ditto.
+	(check_effective_target_has_arch_ppc64): Ditto.
+
+2022-08-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* lib/target-supports.exp (check_effective_target_has_arch_ppc64): New.
+
+2022-08-04  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-03-25  Peter Bergner  <bergner@linux.ibm.com>
+
+	* g++.dg/pr65240-1.C: Use -mdejagnu-cpu=.  Remove dg-skip-if.
+	* g++.dg/pr65240-2.C: Likewise.
+	* g++.dg/pr65240-3.C: Likewise.
+	* g++.dg/pr65240-4.C: Likewise.
+	* g++.dg/pr65242.C: Likewise.
+	* g++.dg/pr67211.C: Likewise.
+	* g++.dg/pr69667.C: Likewise.
+	* g++.dg/pr71294.C: Likewise.
+	* g++.dg/pr84279.C: Likewise.
+	* g++.dg/torture/ppc-ldst-array.C: Likewise.
+	* gfortran.dg/nint_p7.f90: Likewise.
+	* gfortran.dg/pr102860.f90: Likewise.
+	* gcc.target/powerpc/fusion.c: Use -mdejagnu-cpu= and -mdejagnu-tune=.
+	* gcc.target/powerpc/fusion2.c: Likewise.
+	* gcc.target/powerpc/test_mffsl.c: Likewise.
+	* gfortran.dg/pr47614.f: Likewise.
+	* gfortran.dg/pr58968.f: Likewise.
+
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* c-c++-common/pr97498.c: New test.
+	* gcc.dg/pragma-message.c: Adapt for improved warning locations.
+
+2022-08-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106091
+	* gcc.target/powerpc/pr106091.c: New test.
+
+2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103504
+	* gfortran.dg/pr103504.f90: New test.
+
+2022-07-22  Surya Kumari Jangala  <jskumari@linux.vnet.ibm.com>
+
+	Backported from master:
+	2022-06-14  Surya Kumari Jangala  <jskumari@linux.ibm.com>
+
+	PR rtl-optimization/105041
+	* gcc.target/powerpc/pr105041.c: New test.
+
+2022-07-16  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-07-15  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/104313
+	* gfortran.dg/pr104313.f: New test.
+
+2022-07-13  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/105860
+	* gcc.dg/tree-ssa/alias-access-path-13.c: New test.
+	* gcc.dg/tree-ssa/pr105860.c: Likewise.
+
+2022-07-05  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-07-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106139
+	* gdc.dg/pr106139a.d: New test.
+	* gdc.dg/pr106139b.d: New test.
+	* gdc.dg/pr106139c.d: New test.
+	* gdc.dg/pr106139d.d: New test.
+	* gdc.test/fail_compilation/ice20264.d: New test.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-30  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103137
+	PR fortran/103138
+	PR fortran/103693
+	PR fortran/105243
+	* gfortran.dg/class_58.f90: Fix test.
+	* gfortran.dg/class_73.f90: New test.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-29  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106121
+	* gfortran.dg/extends_type_of_4.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105954
+	* gfortran.dg/pr105954.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105691
+	* gfortran.dg/index_6.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105813
+	* gfortran.dg/unpack_vector_1.f90: New test.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/c-c++-common/pr97498.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-Wunused-function" } */
+#pragma GCC diagnostic ignored "-Wunused-function"
+static void f() {} _Pragma("GCC diagnostic error \"-Wunused-function\"") /* { dg-bogus "-Wunused-function" } */
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/g++.dg/cpp1z/fold13.C
@@ -0,0 +1,29 @@
+// { dg-do compile { target c++17 } }
+// Verify constexpr evaluation of a large left fold logical expression
+// isn't quadratic in the size of the expanded expression.
+
+template<int> struct S { static constexpr bool value = true; };
+
+template<class T, T...> struct integer_sequence { };
+
+template<class T, T N>
+using make_integer_sequence
+#if __has_builtin(__make_integer_seq)
+  = __make_integer_seq<integer_sequence, T, N>;
+#else
+  = integer_sequence<T, __integer_pack(N)...>;
+#endif
+
+template<int... Is>
+constexpr bool f_impl(integer_sequence<int, Is...>) {
+  return (... && S<Is>::value);
+}
+
+static_assert(f_impl(make_integer_sequence<int, 1024>()));
+
+template<int... Is>
+constexpr bool g_impl(integer_sequence<int, Is...>) {
+  return (... || !S<Is>::value);
+}
+
+static_assert(!g_impl(make_integer_sequence<int, 1024>()));
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/g++.dg/cpp2a/constinit18.C
@@ -0,0 +1,12 @@
+// PR c++/104066
+// { dg-do compile { target c++20 } }
+
+constinit void (*p)() = nullptr;
+constinit void (*pp)() = nullptr;
+void fn();
+constinit void (&r)() = fn;
+
+extern constinit long (* const syscall_reexported) (long, ...);
+
+constinit void bad (); // { dg-error ".constinit. on function return type is not allowed" }
+constinit void bad () { } // { dg-error ".constinit. on function return type is not allowed" }
--- a/src/gcc/testsuite/g++.dg/guality/guality.exp
+++ b/src/gcc/testsuite/g++.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
     return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
--- a/src/gcc/testsuite/g++.dg/pr65240-1.C
+++ b/src/gcc/testsuite/g++.dg/pr65240-1.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
--- a/src/gcc/testsuite/g++.dg/pr65240-2.C
+++ b/src/gcc/testsuite/g++.dg/pr65240-2.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
--- a/src/gcc/testsuite/g++.dg/pr65240-3.C
+++ b/src/gcc/testsuite/g++.dg/pr65240-3.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=medium -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=medium -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
--- a/src/gcc/testsuite/g++.dg/pr65240-4.C
+++ b/src/gcc/testsuite/g++.dg/pr65240-4.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power7 -O3 -ffast-math -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power7 -O3 -ffast-math -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
--- a/src/gcc/testsuite/g++.dg/pr65242.C
+++ b/src/gcc/testsuite/g++.dg/pr65242.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3" } */
 
 class A {
 public:
--- a/src/gcc/testsuite/g++.dg/pr67211.C
+++ b/src/gcc/testsuite/g++.dg/pr67211.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power7 -mtune=power8 -O3 -w" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3 -w" } */
 
 /* target/67211, compiler got a 'insn does not satisfy its constraints' error.  */
 
--- a/src/gcc/testsuite/g++.dg/pr69667.C
+++ b/src/gcc/testsuite/g++.dg/pr69667.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power8 -w -std=c++14" } */
+/* { dg-options "-mdejagnu-cpu=power8 -w -std=c++14" } */
 
 /* target/69667, compiler got
    internal compiler error: Max. number of generated reload insns per insn is achieved (90)  */
--- a/src/gcc/testsuite/g++.dg/pr71294.C
+++ b/src/gcc/testsuite/g++.dg/pr71294.C
@@ -1,7 +1,6 @@
 // { dg-do compile { target { powerpc64*-*-* && lp64 } } }
 // { dg-require-effective-target powerpc_p8vector_ok } */
-// { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } }
-// { dg-options "-mcpu=power8 -O3 -fstack-protector" }
+// { dg-options "-mdejagnu-cpu=power8 -O3 -fstack-protector" }
 
 // PAR target/71294 failed because RELOAD could not figure how create a V2DI
 // vector that auto vectorization created with each element being the same
--- a/src/gcc/testsuite/g++.dg/pr84279.C
+++ b/src/gcc/testsuite/g++.dg/pr84279.C
@@ -1,8 +1,8 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-O3 -mcpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-O3 -mdejagnu-cpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
 
 template <typename, typename T> struct E { T e; };
 struct J {
--- a/src/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
+++ b/src/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
@@ -1,6 +1,5 @@
 /* { dg-do compile { target { powerpc64*-*-* } } } */
-/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8" } */
+/* { dg-options "-mdejagnu-cpu=power8" } */
 
 /* When compiled with C++, this code was breaking because of different
    tree representations of arrays between C and C++.  */
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/g++.dg/torture/pr106131.C
@@ -0,0 +1,34 @@
+// { dg-do run { target c++11 } }
+
+struct Pair {
+    int a, b;
+    Pair(const Pair &) = default;
+    Pair(int _a, int _b) : a(_a), b(_b) {}
+    Pair &operator=(const Pair &z) {
+	a = z.a;
+	b = z.b;
+	return *this;
+    }
+};
+
+const int &max(const int &a, const int &b)
+{
+  return a < b ? b : a;
+}
+
+int foo(Pair x, Pair y)
+{
+  return max(x.b, y.b);
+}
+
+int main()
+{
+  auto f = new Pair[3] {{0, -11}, {0, -8}, {0, 2}};
+  for (int i = 0; i < 1; i++) {
+      f[i] = f[0];
+      if(i == 0)
+	f[i] = f[2];
+      if (foo(f[i], f[1]) != 2)
+	__builtin_abort();
+  }
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/g++.target/powerpc/pr101322.C
@@ -0,0 +1,17 @@
+/* PR target/101322 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Verify we don't ICE on the following test cases.  */
+
+void
+foo (char *resp, char *vpp)
+{
+  __builtin_vsx_disassemble_pair (resp, (__vector_pair *) vpp);
+}
+
+void
+bar (char *resp, char *vpp)
+{
+  __builtin_mma_disassemble_acc (resp, (__vector_quad *)vpp);
+}
--- a/src/gcc/testsuite/gcc.dg/guality/guality.exp
+++ b/src/gcc/testsuite/gcc.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
     return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
--- a/src/gcc/testsuite/gcc.dg/pragma-message.c
+++ b/src/gcc/testsuite/gcc.dg/pragma-message.c
@@ -42,9 +42,11 @@
 #pragma message ("Okay " THREE)  /* { dg-message "Okay 3" } */
 
 /* Create a TODO() that prints a message on compilation.  */
-#define DO_PRAGMA(x) _Pragma (#x)
-#define TODO(x) DO_PRAGMA(message ("TODO - " #x))
-TODO(Okay 4)                     /* { dg-message "TODO - Okay 4" } */
+#define DO_PRAGMA(x) _Pragma (#x) /* { dg-line pragma_loc1 } */
+#define TODO(x) DO_PRAGMA(message ("TODO - " #x)) /* { dg-line pragma_loc2 } */
+TODO(Okay 4) /* { dg-message "in expansion of macro 'TODO'" } */
+/* { dg-message "TODO - Okay 4" "test4.1" { target *-*-* } pragma_loc1 } */
+/* { dg-message "in expansion of macro 'DO_PRAGMA'" "test4.2" { target *-*-* } pragma_loc2 } */
 
 #if 0
 #pragma message ("Not printed")
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/torture/pr106112.c
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+__INT32_TYPE__ a = 5, b, c, d;
+__UINT64_TYPE__ e = 20862985922;
+int main()
+{
+  __UINT32_TYPE__ f = 4294967292;
+  e = e | f;
+  c = -1 % ((~f ^ 4294967292) - (e - d));
+  b = ~-~e % ~-d;
+  if (b)
+    a = 0;
+  if (a < 1)
+    __builtin_abort();
+  return 0;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/torture/pr106513.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+typedef __INT64_TYPE__ int64_t;
+
+__attribute__((noinline)) int64_t
+swap64 (int64_t n)
+{
+  return (((n & (((int64_t) 0xff) )) << 56) |
+          ((n & (((int64_t) 0xff) << 8)) << 40) |
+          ((n & (((int64_t) 0xff) << 16)) << 24) |
+          ((n & (((int64_t) 0xff) << 24)) << 8) |
+          ((n & (((int64_t) 0xff) << 32)) >> 8) |
+          ((n & (((int64_t) 0xff) << 40)) >> 24) |
+          ((n & (((int64_t) 0xff) << 48)) >> 40) |
+          ((n & ((int64_t)(0xffull << 56))) >> 56));
+}
+
+int main (void)
+{
+  volatile int64_t n = 0x8000000000000000ll;
+
+  if (swap64(n) != 0xffffffffffffff80ll)
+    __builtin_abort ();
+
+  return 0;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-fre1" } */
+
+struct inn
+{
+  int val;
+};
+
+struct biggerstruct
+{
+  int a, b;
+};
+
+union foo
+{
+  struct inn inn;
+  struct biggerstruct baz;
+} *fooptr;
+
+struct bar
+{
+  union foo foo;
+  int val2;
+} *barptr;
+
+int
+test ()
+{
+  union foo foo;
+  foo.inn.val = 0;
+  barptr->val2 = 123;
+  *fooptr = foo;
+  return barptr->val2;
+}
+
+/* { dg-final { scan-tree-dump-times "return 123" 1 "fre1"} } */
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c
@@ -0,0 +1,63 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+struct S1  {
+        unsigned int _0;
+        unsigned int _1;
+} ;
+struct S2  {
+        struct S1 _s1;
+        unsigned long _x2;
+} ;
+
+struct ufld_type1  {
+        unsigned int _u1t;
+        struct S2 _s2;
+} ;
+
+struct ufld_type2  {
+        unsigned int _u2t;
+        struct S1 _s1;
+} ;
+struct parm_type {
+        union {
+                struct ufld_type1 var_1;
+                struct ufld_type2 var_2;
+        } U;
+};
+
+struct parm_type  bad_function( struct parm_type arg0 )
+{
+        struct parm_type rv;
+        struct S2 var4;
+        switch( arg0.U.var_2._u2t ) {
+        case 4294967041:
+                var4._s1 = arg0.U.var_1._s2._s1;
+                rv.U.var_1._u1t = 4294967041;
+                rv.U.var_1._s2 = var4;
+                break;
+        case 4294967043:
+                rv.U.var_2._u2t = 4294967043;
+                rv.U.var_2._s1 = arg0.U.var_2._s1;
+                break;
+        default:
+                break;
+        }
+        return rv;
+}
+
+int main() {
+        struct parm_type val;
+        struct parm_type out;
+        val.U.var_2._u2t = 4294967043;
+        val.U.var_2._s1._0 = 0x01010101;
+        val.U.var_2._s1._1 = 0x02020202;
+        out = bad_function(val);
+	if (val.U.var_2._u2t != 4294967043)
+	  __builtin_abort ();
+        if (out.U.var_2._s1._0 != 0x01010101)
+	  __builtin_abort ();
+        if (val.U.var_2._s1._1 != 0x02020202 )
+	  __builtin_abort ();
+	return 0;
+}
--- a/src/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
@@ -9,4 +9,4 @@ __attribute__ ((target("branch-protection=bti"),
 f10_bti ()
 {
 }
-/* { dg-final { scan-assembler "f10_bti:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
+/* { dg-final { scan-assembler "hint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
@@ -9,4 +9,4 @@ __attribute__ ((target("branch-protection=bti+pac-ret+leaf"),
 f10_pac ()
 {
 }
-/* { dg-final { scan-assembler "f10_pac:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
+/* { dg-final { scan-assembler "hint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr98776.c
@@ -0,0 +1,11 @@
+/* { dg-do "compile" } */
+/* { dg-options "-O1 -fpatchable-function-entry=1 -fasynchronous-unwind-tables" } */
+
+/* Test the placement of the .LPFE1 label.  */
+
+void
+foo (void)
+{
+}
+
+/* { dg-final { scan-assembler "\t\.cfi_startproc\n.*\.LPFE1:\n\tnop\n\tret\n" } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
@@ -248,6 +248,26 @@
 #error "__ARM_FEATURE_CRC32 is not defined but should be!"
 #endif
 
+#pragma GCC target ("arch=armv8.2-a")
+#ifdef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is defined but should not be!"
+#endif
+
+#pragma GCC target ("arch=armv8.2-a+rcpc")
+#ifndef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is not defined but should be!"
+#endif
+
+#pragma GCC target ("+norcpc")
+#ifdef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is defined but should not be!"
+#endif
+
+#pragma GCC target ("arch=armv8.3-a")
+#ifndef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is not defined but should be!"
+#endif
+
 int
 foo (int a)
 {
--- a/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkas\tp[0-9]+\.b, p[0-9]+/m,} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrka\t} } } */
+/* { dg-final { scan-assembler-times {\tbrka\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkas\t} } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkbs\tp[0-9]+\.b, p[0-9]+/m,} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrkb\t} } } */
+/* { dg-final { scan-assembler-times {\tbrkb\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkbs\t} } } */
--- a/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
+++ b/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkns\t} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrkn\t} } } */
+/* { dg-final { scan-assembler-times {\tbrkn\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkns\t} } } */
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <arm_sve.h>
+
+void
+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)
+{
+  svbool_t res = svbrkn_z (pg, x, y);
+  *any = svptest_any (svptrue_b8 (), res);
+  *ptr = res;
+}
+
+int
+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
+{
+  svbool_t res = svbrkn_z (pg, x, y);
+  return svptest_any (svptrue_b8 (), res);
+}
+
+/* { dg-final { scan-assembler-times {\tbrkns\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkn\t} } } */
+/* { dg-final { scan-assembler-not {\tptest\t} } } */
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/i386/pr107304.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -march=tigerlake" } */
+
+#include <stdint.h>
+
+typedef union {
+  uint8_t v __attribute__((aligned(256))) __attribute__ ((vector_size(64 * sizeof(uint8_t))));
+  uint8_t i[64] __attribute__((aligned(256)));
+} stress_vec_u8_64_t;
+
+typedef struct {
+ struct {
+  stress_vec_u8_64_t s;
+  stress_vec_u8_64_t o;
+  stress_vec_u8_64_t mask1;
+  stress_vec_u8_64_t mask2;
+ } u8_64;
+} stress_vec_data_t;
+
+__attribute__((target_clones("arch=skylake", "default"))) 
+void
+stress_vecshuf_u8_64(stress_vec_data_t *data)
+{
+  stress_vec_u8_64_t *__restrict s;
+  stress_vec_u8_64_t *__restrict mask1;
+  stress_vec_u8_64_t *__restrict mask2;
+  register int i;
+
+  s = &data->u8_64.s;
+  mask1 = &data->u8_64.mask1;
+  mask2 = &data->u8_64.mask2;
+
+  for (i = 0; i < 256; i++) {	/* was i < 65536 */
+      stress_vec_u8_64_t tmp;
+
+      tmp.v = __builtin_shuffle(s->v, mask1->v);
+      s->v = __builtin_shuffle(tmp.v, mask2->v);
+  }
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/i386/pr107863.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx2 -O" } */
+
+typedef char v16qi __attribute__((vector_size(16)));
+
+v16qi foo(v16qi a){
+  return __builtin_ia32_vec_set_v16qi (a, -1, 2);
+}
--- a/src/gcc/testsuite/gcc.target/powerpc/fusion.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/fusion.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mdejagnu-cpu=power7 -mtune=power8 -O3 -dp" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3 -dp" } */
 
 #define LARGE 0x12345
 
--- a/src/gcc/testsuite/gcc.target/powerpc/fusion2.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/fusion2.c
@@ -2,7 +2,7 @@
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-skip-if "" { powerpc*le-*-* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mdejagnu-cpu=power7 -mtune=power8 -O3" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3" } */
 
 vector double fusion_vector (vector double *p) { return p[2]; }
 
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr103353.c
@@ -0,0 +1,22 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* If the default cpu type is power10 or later, MMA is enabled by default.
+   To keep the test point available all the time, this case specifies
+   -mdejagnu-cpu=power6 to make it be tested without MMA.  */
+/* { dg-options "-maltivec -mdejagnu-cpu=power6" } */
+
+/* Verify there is no ICE and don't check the error messages on MMA
+   requirement since they could be fragile and are not test points
+   of this case.  */
+/* { dg-excess-errors "pr103353" } */
+
+void
+foo (__vector_pair *dst, double *x)
+{
+  dst[0] = __builtin_vsx_lxvp (0, (__vector_pair *)(void *)x);
+}
+
+void
+bar (__vector_pair *src, double *x)
+{
+  __builtin_vsx_stxvp (src[0], 0, (__vector_pair *)(void *)x);
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr105041.c
@@ -0,0 +1,22 @@
+/* { dg-options "-mdejagnu-cpu=power4 -O2 -fcompare-debug -frename-registers" } */
+
+double m;
+int n;
+
+unsigned int
+foo (unsigned int x, int y)
+{
+  long long int a = y, b = !a;
+  int c = 0;
+
+  if (b != x)
+    while ((int) m == a)
+      {
+        c = a;
+        a = 0;
+      }
+
+  n = b = y;
+
+  return x + c;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106017.c
@@ -0,0 +1,19 @@
+/* PR target/106017 */
+/* { dg-options "-O1 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Make sure we do not flag any errors on the following test cases.  */
+
+void takeacc(__vector_quad *);
+void
+foo (void)
+{
+  __vector_quad arr[4];
+  takeacc (arr);
+}
+
+unsigned char *
+bar (__vector_quad *a)
+{
+  return (unsigned char *)a;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106091.c
@@ -0,0 +1,15 @@
+/* { dg-options "-O -fnon-call-exceptions -fno-tree-dce -fno-tree-forwprop -w" } */
+
+/* Verify there is no ICE.  */
+
+typedef short __attribute__ ((__vector_size__ (64))) V;
+V v, w;
+
+inline V foo (V a, V b);
+
+V
+foo (V a, V b)
+{
+  b &= v < b;
+  return (V){foo (b, w)[3], (V){}[3]};
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106736-1.c
@@ -0,0 +1,20 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-1" } */
+
+extern void bar (__vector_quad *);
+
+void
+foo (__vector_quad *a, __vector_quad *b)
+{
+  __vector_quad arr[2] = {*a, *b};
+  bar (&arr[0]);
+}
+
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106736-2.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-2" } */
+
+void
+foo (__vector_pair *a, __vector_pair *b)
+{
+  *a = *b;
+}
+
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106736-3.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-3" } */
+
+__vector_quad ga;
+void
+foo (__vector_quad *a)
+{
+  ga = *a;
+}
+
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106736-4.c
@@ -0,0 +1,19 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-4" } */
+
+__vector_quad ga;
+__vector_quad gb;
+void
+foo ()
+{
+  gb = ga;
+}
+
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr106736-5.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-5" } */
+
+__vector_pair ga;
+void
+foo (__vector_pair *a)
+{
+  *a = ga;
+}
+
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr96072.c
@@ -0,0 +1,14 @@
+/* { dg-options "-O2" } */
+
+/* This used to ICE with the SYSV ABI (PR96072).  */
+
+void
+he (int jn)
+{
+  {
+    int bh[jn];
+    if (jn != 0)
+      goto wa;
+  }
+wa:;
+}
--- a/src/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
+++ b/src/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
@@ -1,5 +1,6 @@
 /* { dg-do run { target { powerpc*-*-* } } } */
-/* { dg-options "-O2 -std=c99" } */
+/* { dg-options "-O2 -std=c99 -mdejagnu-cpu=power9" } */
+/* { dg-require-effective-target p9vector_hw } */
 
 #ifdef DEBUG
 #include <stdio.h>
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/s390/pr106355-1.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-foptimize-sibling-calls" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar4} } } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar8} } } */
+
+/* Parameter E is passed in GPR 6 which is call-saved which prohibits
+   sibling call optimization.  This must hold true also if the mode of the
+   parameter is BLKmode.  */
+
+/* 4 byte */
+
+typedef struct
+{
+  char x;
+  char y[3];
+} t4;
+
+extern t4 e4;
+
+extern void bar4 (int a, int b, int c, int d, t4 e4);
+
+void foo4 (int a, int b, int c, int d)
+{
+  bar4 (a, b, c, d, e4);
+}
+
+/* 8 byte */
+
+typedef struct
+{
+  short x;
+  char y[6];
+} t8;
+
+extern t8 e8;
+
+extern void bar8 (int a, int b, int c, int d, t8 e8);
+
+void foo8 (int a, int b, int c, int d)
+{
+  bar8 (a, b, c, d, e8);
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/s390/pr106355-2.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { s390-*-* } } } */
+/* { dg-options "-foptimize-sibling-calls -mzarch" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar} } } */
+
+/* This tests function s390_call_saved_register_used where
+   GET_CODE (parm_rtx) == PARALLEL holds.  */
+
+#include "pr106355.h"
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/s390/pr106355-3.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { s390-*-* } } } */
+/* { dg-options "-foptimize-sibling-calls -mesa" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar} } } */
+
+/* This tests function s390_call_saved_register_used where
+   REG_P (parm_rtx) and nregs == 2 holds.  */
+
+#include "pr106355.h"
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/s390/pr106355.h
@@ -0,0 +1,18 @@
+/* For the S/390 ABI parameter D is passed in GPR 5 and 6 and the latter is
+   call-saved which prohibits sibling call optimization.  This must hold true
+   also if the mode of the parameter is BLKmode.  */
+
+typedef struct
+{
+  short x;
+  char y[6];
+} t;
+
+extern t d;
+
+extern void bar (int a, int b, int c, t d);
+
+void foo (int a, int b, int c)
+{
+  bar (a, b, c, d);
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d
@@ -0,0 +1,2 @@
+module imports.pr108050.mod1;
+string[] split() { return null; }
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d
@@ -0,0 +1,2 @@
+module imports.pr108050.mod2;
+string[] split() { return null; }
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/imports/pr108050/package.d
@@ -0,0 +1,2 @@
+module imports.pr108050;
+public import imports.pr108050.mod1, imports.pr108050.mod2;
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/pr106139a.d
@@ -0,0 +1,36 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias A = int[4];
+
+static if (__traits(compiles, __vector(A))):
+
+A vector2array(__vector(A) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(A) v)
+{
+    a = cast(A)v;
+}
+
+__vector(A) array2vector(A a)
+{
+    return cast(__vector(A)) a;
+}
+
+void array2vector(ref __vector(A) v, A a)
+{
+    v = cast(__vector(A))a;
+}
+
+A vector2array_array(__vector(A) v)
+{
+    return v.array;
+}
+
+void vector2array_array(ref A a, __vector(A) v)
+{
+    a = v.array;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/pr106139b.d
@@ -0,0 +1,36 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias A = float[4];
+
+static if (__traits(compiles, __vector(A))):
+
+A vector2array(__vector(A) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(A) v)
+{
+    a = cast(A)v;
+}
+
+__vector(A) array2vector(A a)
+{
+    return cast(__vector(A)) a;
+}
+
+void array2vector(ref __vector(A) v, A a)
+{
+    v = cast(__vector(A))a;
+}
+
+A vector2array_array(__vector(A) v)
+{
+    return v.array;
+}
+
+void vector2array_array(ref A a, __vector(A) v)
+{
+    a = v.array;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/pr106139c.d
@@ -0,0 +1,27 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias V = int[4];
+alias A = float[4];
+
+static if (__traits(compiles, __vector(V))):
+
+A vector2array(__vector(V) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(V) v)
+{
+    a = cast(A)v;
+}
+
+__vector(V) array2vector(A a)
+{
+    return cast(__vector(V)) a;
+}
+
+void array2vector(ref __vector(V) v, A a)
+{
+    v = cast(__vector(V))a;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/pr106139d.d
@@ -0,0 +1,27 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias V = float[4];
+alias A = int[4];
+
+static if (__traits(compiles, __vector(V))):
+
+A vector2array(__vector(V) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(V) v)
+{
+    a = cast(A)v;
+}
+
+__vector(V) array2vector(A a)
+{
+    return cast(__vector(V)) a;
+}
+
+void array2vector(ref __vector(V) v, A a)
+{
+    v = cast(__vector(V))a;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/pr107592.d
@@ -0,0 +1,13 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107592
+// { dg-do compile }
+
+void test107592(Things...)(Things things)
+{
+    label:
+    foreach (thing; things)
+    {
+        continue label;
+    }
+}
+
+alias a107592 = test107592!(string);
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.dg/pr108050.d
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-additional-sources "imports/pr108050/package.d imports/pr108050/mod1.d imports/pr108050/mod2.d" }
+// { dg-options "-g" }
+import imports.pr108050 : split;
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gdc.test/fail_compilation/ice20264.d
@@ -0,0 +1,13 @@
+/*
+DISABLED: freebsd32 linux32 osx32 win32
+TEST_OUTPUT:
+---
+fail_compilation/ice20264.d(12): Error: `cast(__vector(float[4]))a` is not an lvalue and cannot be modified
+---
+*/
+
+void foo(float *a)
+{
+    alias float4 = __vector(float[4]);
+    cast(float4)(a) = 1.0f;
+}
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/PR100029.f90
@@ -0,0 +1,22 @@
+! { dg-do run }
+!
+! Test the fix for PR100029
+!
+
+program foo_p
+  implicit none
+
+  type :: foo_t
+  end type foo_t
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+  end subroutine foo_s
+
+end program foo_p
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/PR100040.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+!
+! Test the fix for PR100040
+!
+
+program foo_p
+  implicit none
+
+  integer, parameter :: n = 11
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+  
+  type(foo_t), parameter :: a = foo_t(n)
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+  if(.not.allocated(pout)) stop 1
+  if(pout%i/=n) stop 2
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(0)
+      that = a
+    rank default
+      stop 3
+    end select
+  end subroutine foo_s
+
+end program foo_p
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/PR100132.f90
@@ -0,0 +1,75 @@
+! { dg-do run }
+!
+! Test the fix for PR100132
+!
+
+module main_m
+  implicit none
+
+  private
+
+  public :: &
+    foo_t
+
+  public :: &
+    set,    &
+    get
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  type(foo_t), save, pointer :: data => null()
+
+contains
+
+  subroutine set(this)
+    class(foo_t), pointer, intent(in) :: this
+
+    if(associated(data)) stop 1
+    data => this
+  end subroutine set
+
+  subroutine get(this)
+    type(foo_t), pointer, intent(out) :: this
+
+    if(.not.associated(data)) stop 4
+    this => data
+    nullify(data)
+  end subroutine get
+
+end module main_m
+
+program main_p
+
+  use :: main_m, only: &
+    foo_t, set, get
+
+  implicit none
+
+  integer, parameter :: n = 1000
+
+  type(foo_t), pointer :: ps
+  type(foo_t),  target :: s
+  integer              :: i, j, yay, nay
+
+  yay = 0
+  nay = 0
+  do i = 1, n
+    s%i = i
+    call set(s)
+    call get(ps)
+    if(.not.associated(ps)) stop 13
+    j = ps%i
+    if(i/=j) stop 14
+    if(i/=s%i) stop 15
+    if(ps%i/=s%i) stop 16
+    if(associated(ps, s))then
+      yay = yay + 1
+    else
+      nay = nay + 1
+    end if
+  end do
+  if((yay/=n).or.(nay/=0)) stop 17
+
+end program main_p
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/PR100245.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR100245
+!
+
+program main_p
+
+  implicit none
+
+  type :: foo_t
+    integer :: a
+  end type foo_t
+
+  integer, parameter :: a = 42
+
+  class(foo_t), allocatable :: val
+  class(foo_t), allocatable :: rs1
+  type(foo_t),  allocatable :: rs2
+
+  allocate(val, source=foo_t(42))
+  if (val%a/=a) stop 1
+  rs1 = val
+  if (rs1%a/=a) stop 2
+  rs2 = val
+  if (rs2%a/=a) stop 3
+  deallocate(val, rs1, rs2)
+
+end program main_p
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/associate_26a.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+! Test the fix for PR78152 and the followup in PR82868
+!
+! Contributed by <physiker@toast2.net>
+!
+program co_assoc
+  implicit none
+  integer, parameter :: p = 5
+  real, allocatable :: a(:,:)[:,:]
+  allocate (a(p,p)[2,*])
+  associate (i => a(1:p, 1:p))
+  end associate
+end program co_assoc
--- a/src/gcc/testsuite/gfortran.dg/class_58.f90
+++ b/src/gcc/testsuite/gfortran.dg/class_58.f90
@@ -9,5 +9,5 @@ subroutine s
   end type
   class(t), parameter :: x = t()  ! { dg-error "cannot have the PARAMETER attribute" }
   class(t), parameter :: y = x    ! { dg-error "cannot have the PARAMETER attribute" }
-  class(t) :: z = x               ! { dg-error "must be dummy, allocatable or pointer" }
+  class(t) :: z = t()             ! { dg-error "must be dummy, allocatable or pointer" }
 end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/class_73.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! Error recovery on invalid CLASS(), PARAMETER declarations
+! PR fortran/103137
+! PR fortran/103138
+! PR fortran/103693
+! PR fortran/105243
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     character(3) :: c = '(a)'
+  end type
+  class(t), parameter :: x = 1.  ! { dg-error "PARAMETER attribute" }
+  class(*), parameter :: y = t() ! { dg-error "PARAMETER attribute" }
+  class(*), parameter :: z = 1   ! { dg-error "PARAMETER attribute" }
+  print x%c                      ! { dg-error "Syntax error" }
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/extends_type_of_4.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! PR fortran/106121 - ICE in gfc_simplify_extends_type_of
+! Contributed by G.Steinmetz
+
+program p
+   type t
+   end type
+   type(t)  :: x
+   class(t) :: y               ! { dg-error "dummy, allocatable or pointer" }
+   print *, extends_type_of (x, y)
+end
+
+subroutine s
+   type t
+      integer :: i
+   end type
+   type(t)  :: x
+   class(t) :: y               ! { dg-error "dummy, allocatable or pointer" }
+   stop extends_type_of (x, y) ! { dg-error "STOP code" }
+end
--- a/src/gcc/testsuite/gfortran.dg/guality/guality.exp
+++ b/src/gcc/testsuite/gfortran.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
   return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-std=f2018" }
+! PR fortran/103413
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     class(*), allocatable :: a
+  end type
+  type(t) :: x
+  allocate (x%a, source=z'1') ! { dg-error "type incompatible" }
+  allocate (x%a, mold=z'1')   ! { dg-error "type incompatible" }
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/index_6.f90
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/105691 - Incorrect calculation of INDEX(str1,str2) at compile time
+
+program main
+  implicit none
+  integer :: i
+  character(*), parameter :: s1 = "fortran.f90"
+  character(*), parameter :: s2 = "fortran"
+  character(*), parameter :: s3 = s2 // "*"
+  integer, parameter :: i0    = index(s1, s2)
+  integer, parameter :: i1    = index(s1, s2, back= .true.)
+  integer, parameter :: i2(*) = index(s1, s2, back=[.true.,.false.])
+  integer, parameter :: i3(*) = index(s1, s2, back=[(i==1, i=1,2)] )
+  integer, parameter :: i4    = index(s1, s3)
+  integer, parameter :: i5    = index(s1, s3, back= .true.)
+  integer, parameter :: i6(*) = index(s1, s3, back=[.true.,.false.])
+  integer, parameter :: i7(*) = index(s1, s3, back=[(i==1, i=1,2)] )
+  integer, parameter :: i8    = index(s1, "f", back= .true.)
+  if (     i0 /= 1 ) stop 1
+  if (     i1 /= 1 ) stop 2
+  if (any (i2 /= 1)) stop 3
+  if (any (i3 /= 1)) stop 4
+  if (     i4 /= 0 ) stop 5
+  if (     i5 /= 0 ) stop 6
+  if (any (i6 /= 0)) stop 7
+  if (any (i7 /= 0)) stop 8
+  if (i8 /= len(s1)-2) stop 9
+end program
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! { dg-final { scan-tree-dump-times "CLOBBER" 2 "original" } }
+!
+! PR fortran/106817
+! Check that for an actual argument whose dummy is INTENT(OUT),
+! the clobber that is emitted in the caller before a procedure call
+! happens after any expression depending on the argument value has been
+! evaluated.
+! 
+
+module m
+  implicit none
+contains
+  subroutine copy1(out, in)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy1
+  subroutine copy2(in, out)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy2
+end module m
+
+program p
+  use m
+  implicit none
+  integer :: a, b
+
+  ! Clobbering of a should happen after a+1 has been evaluated.
+  a = 3
+  call copy1(a, a+1)
+  if (a /= 4) stop 1
+
+  ! Clobbering order does not depend on the order of arguments.
+  ! It should also come last with reversed arguments.
+  b = 12
+  call copy2(b+1, b)
+  if (b /= 13) stop 2
+
+end program p
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/intent_out_15.f90
@@ -0,0 +1,27 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/105012
+! The following case was triggering an ICE because of a clobber
+! on the DERFC function decl instead of its result.
+
+module error_function
+integer, parameter :: r8 = selected_real_kind(12) ! 8 byte real
+contains
+SUBROUTINE CALERF_r8(ARG, RESULT, JINT)
+   integer, parameter :: rk = r8
+   real(rk), intent(in)  :: arg
+   real(rk), intent(out) :: result
+   IF (Y .LE. THRESH) THEN
+   END IF
+end SUBROUTINE CALERF_r8
+FUNCTION DERFC(X)
+   integer, parameter :: rk = r8 ! 8 byte real
+   real(rk), intent(in) :: X
+   real(rk) :: DERFC
+   CALL CALERF_r8(X, DERFC, JINT)
+END FUNCTION DERFC
+end module error_function
+
+! { dg-final { scan-tree-dump-times "CLOBBER" 1 "original" } }
+! { dg-final { scan-tree-dump "__result_derfc = {CLOBBER};" "original" } }
--- a/src/gcc/testsuite/gfortran.dg/nint_p7.f90
+++ b/src/gcc/testsuite/gfortran.dg/nint_p7.f90
@@ -1,8 +1,7 @@
 ! Fortran
 ! { dg-do compile { target { powerpc*-*-* } } }
 ! { dg-require-effective-target powerpc_vsx_ok } 
-! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } 
-! { dg-options "-O2 -mcpu=power7 -ffast-math" } 
+! { dg-options "-O2 -mdejagnu-cpu=power7 -ffast-math" } 
 ! { dg-final { scan-assembler-times "xsrdpi" 2 } } 
 
 	subroutine test_nint(x4,x8)
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/null_actual_3.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-fallow-argument-mismatch -w" }
+! PR fortran/107576
+! Contributed by G.Steinmetz
+
+program p
+  implicit none
+  interface
+     subroutine r(y)
+       integer, pointer :: y(:)
+     end subroutine r
+  end interface
+  integer, pointer :: z(:) => null()
+  call r(z)
+  call s(z)
+  call r(null(z))
+  call s(null(z)) ! { dg-error "requires an explicit interface" }
+end
--- a/src/gcc/testsuite/gfortran.dg/pr102860.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr102860.f90
@@ -1,8 +1,7 @@
 ! PR middle-end/102860
 ! { dg-do compile { target { powerpc*-*-* } } }
 ! { dg-require-effective-target powerpc_vsx_ok } 
-! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power10" } } 
-! { dg-options "-O2 -mcpu=power10" } 
+! { dg-options "-O2 -mdejagnu-cpu=power10" } 
 
 function foo(a)
   integer(kind=4) :: a(1024)
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr103504.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! PR fortran/103504 - ICE in get_sym_storage_size, at fortran/interface.c:2800
+! Contributed by G.Steinmetz
+
+program p
+  implicit none
+  real      :: y(1)
+  character :: b
+  call s(y)
+  call t(y)
+  call u(y)
+  call c(b)
+contains
+  subroutine s(x)
+    real :: x(abs(1.):1)        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine t(x)
+    real :: x(abs(1.):1)        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine u(x)
+    real :: x(1:abs(1.))        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine c(z)
+    character(len=abs(1.)) :: z ! { dg-error "must be of INTEGER type" }
+  end subroutine c
+end
+
+! { dg-prune-output "must be of INTEGER type" }
--- a/src/gcc/testsuite/gfortran.dg/pr103505.f90
+++ b/src/gcc/testsuite/gfortran.dg/pr103505.f90
@@ -3,7 +3,9 @@
 ! Testcase by G.Steinmetz
 
 program p
-  integer, parameter :: a((2.))   = [4,8] ! { dg-error "scalar INTEGER" }
-  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "scalar INTEGER" }
-  print *, a(1:1)                         ! { dg-error "Syntax error" }
+  integer, parameter :: a((2.))   = [4,8] ! { dg-error "INTEGER type" }
+  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "INTEGER type" }
+  print *, a(1:1)
 end
+
+! { dg-prune-output "Parameter array" }
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr103694.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/103694 - ICE in gfc_conv_expr_op
+! Contributed by G.Steinmetz
+
+subroutine s
+  type t
+     integer :: a(2)
+  end type
+  type(t) :: x((0.)/0)
+  integer :: n = size(x(1)%a) ! { dg-error "does not reduce to a constant expression" }
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr104313.f
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-additional-options "-ff2c -fdump-tree-original" }
+!
+! PR fortran/104313 - ICE verify_gimple failed with -ff2c
+! Contributed by G.Steinmetz
+
+      function f(a)
+      return
+      end
+
+! { dg-final { scan-tree-dump-times "return" 1 "original" } }
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr105633.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/105633 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1,2] ! { dg-error "deferred shape" }
+  print *, [a([1,2])]
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr105954.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/105954 - ICE in gfc_element_size, at fortran/target-memory.cc:132
+! Contributed by G.Steinmetz
+
+program p
+  use iso_c_binding, only: c_float, c_sizeof
+  implicit none
+  integer, parameter :: n = -99
+  type t
+     real :: b(3,7:n)
+  end type
+  type, bind(c) :: u
+     real(c_float) :: b(3,7:n)
+  end type
+  type(t) :: d
+  type(u) :: e
+  integer, parameter :: k = storage_size(d)
+  integer, parameter :: m = sizeof(d)
+  integer, parameter :: l = c_sizeof(e)
+  if (k /= 0) stop 1
+  if (m /= 0) stop 2
+  if (l /= 0) stop 3
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr106331.f90
@@ -0,0 +1,7 @@
+! { dg-do run }
+! { dg-options "-Og" }
+
+PROGRAM main
+  CHARACTER(LEN=24) :: a(2)
+  a = ''
+END PROGRAM
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr106857.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/106857 - ICE in gfc_simplify_pack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n
+  end type
+  type(t), parameter :: a(2,2) = t(1)
+  type(t), parameter :: b(4) = reshape(a, [2])                          ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b, [.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr106985.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106985 - ICE in gfc_simplify_expr
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(2) = 1
+  integer, parameter :: b = a(2) + b ! { dg-error "before its definition is complete" }
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr106986.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106986 - ICE in simplify_findloc_nodim
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1] ! { dg-error "deferred shape" }
+  print *, findloc (a, 1)
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr107054.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/107054 - ICE in gfc_simplify_unpack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n = 0
+  end type
+  type(t), parameter :: a(4) = t(2)
+  type(t), parameter :: b(4) = reshape(a,[2]) ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b,[.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+  type(t), parameter :: d(4) = unpack(c,[.false.,.true.,.false.,.true.],a)
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr107872.f90
@@ -0,0 +1,40 @@
+! { dg-do run }
+!
+! Test the fix for PR107872, where an ICE occurred in
+! resolve.cc(derived_inaccessible) because derived types with
+! recursive allocatable components were not catered for.
+!
+module mod1
+  type t
+     integer :: data
+     type(t), allocatable :: next
+   contains
+     procedure, private :: write_t
+     generic :: write(formatted) => write_t
+  end type
+contains
+  recursive subroutine write_t(this, unit, iotype, v_list, iostat, iomsg)
+    class(t), intent(in) :: this
+    integer, intent(in) :: unit
+    character(*), intent(in) :: iotype
+    integer, intent(in) :: v_list(:)
+    integer, intent(out) :: iostat
+    character(*), intent(inout) :: iomsg
+    if (ALLOCATED(this%next)) &
+         write (unit, '(dt)') this%next
+    write (unit, '(i2)') this%data
+  end subroutine
+end module
+
+  use mod1
+  type(t) :: a
+  character (8) :: buffer
+  a%data = 1
+  allocate (a%next)
+  a%next%data = 2
+  allocate (a%next%next)
+  a%next%next%data = 3
+  write (buffer, '(dt)')a
+  deallocate (a%next)
+  if (trim (buffer) .ne. ' 3 2 1') stop 1
+end
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/pr108131.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR fortran/108131
+!
+! Incorrect array bounds when bound intrinsic used in declaration
+
+program test
+  implicit none
+  integer, parameter :: mg(7:10)                 = 0
+  integer, parameter :: u =   ubound(mg, dim=1)
+  integer, parameter :: cx(-1:ubound(mg, dim=1)) = 1
+  integer, parameter :: dx(lbound(mg, dim=1):ubound(cx, dim=1)) = 2
+
+  write(*,*) ubound(mg, dim=1)
+  write(*,*) ubound(cx, dim=1)
+  if (u /= 10) stop 1
+  if (ubound(mg, dim=1) /= 10) stop 2
+  if (ubound(cx, dim=1) /= 10) stop 3
+  if (ubound(dx, dim=1) /= 10) stop 4
+  if (lbound(mg, dim=1) /=  7) stop 5
+  if (lbound(cx, dim=1) /= -1) stop 6
+  if (lbound(dx, dim=1) /=  7) stop 7
+end program test
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
--- a/src/gcc/testsuite/gfortran.dg/pr47614.f
+++ b/src/gcc/testsuite/gfortran.dg/pr47614.f
@@ -1,6 +1,7 @@
 ! { dg-do run { target { powerpc*-*-* } } }
 ! { dg-skip-if "" { powerpc*-*-darwin* } }
-! { dg-options "-O3 -funroll-loops -ffast-math -mcpu=power4" }
+! { dg-options "-O3 -funroll-loops -ffast-math -mdejagnu-cpu=power4" }
+! { dg-options "-O3 -funroll-loops -ffast-math" { target powerpc64le*-*-linux* } }
 
 
       SUBROUTINE SFCPAR(ZET,NZ,ZMH,TSL,TMES)
--- a/src/gcc/testsuite/gfortran.dg/pr58968.f
+++ b/src/gcc/testsuite/gfortran.dg/pr58968.f
@@ -1,6 +1,6 @@
 C PR rtl-optimization/58968.f
 C { dg-do compile { target powerpc*-*-* } }
-C { dg-options "-mcpu=power7 -O3 -w -ffast-math  -funroll-loops" }
+C { dg-options "-mdejagnu-cpu=power7 -O3 -w -ffast-math  -funroll-loops" }
       SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,
      *            LBST,X,
      *            NX,IAMA,IAMI,IBMA,IBMI,MNUM,IDIM,MSTA,IBO,
new file mode 100644
--- /dev/null
+++ b/src/gcc/testsuite/gfortran.dg/unpack_vector_1.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/105813
+! Fix checking of VECTOR argument to UNPACK when MASK is a variable.
+! Contributed by G.Steinmetz
+
+program p
+  logical, parameter :: mask(2,2) = reshape ([.true.,  .true.,  &
+                                              .false., .true.], &
+                                              shape (mask))
+  print *, unpack ([1,2,3], mask, 0) ! OK
+  print *, unpack ([1,2],   mask, 0) ! { dg-error "must provide at least" }
+end
--- a/src/gcc/testsuite/lib/lto.exp
+++ b/src/gcc/testsuite/lib/lto.exp
@@ -159,6 +159,9 @@ proc lto_prune_warns { text } {
     regsub -all "(^|\n)\[ \t\]*\[\(\]file \[^\n\]* value=\[^\n\]*; file \[^\n\]* value=\[^\n\]*\[)\];" $text "" text
     regsub -all "(^|\n)\[ \t\]*\[^\n\]* definition taken" $text "" text
 
+    # Ignore missing jobserver for tests that do more than 1 LTRANS unit
+    regsub -all "(^|\n)\[^\n\]*: warning: using serial compilation of \[^\n\]*" $text "" text
+
     # Ignore informational notes.
     regsub -all "(^|\n)\[^\n\]*: note: \[^\n\]*" $text "" text
 
--- a/src/gcc/testsuite/lib/prune.exp
+++ b/src/gcc/testsuite/lib/prune.exp
@@ -82,6 +82,13 @@ proc prune_gcc_output { text } {
     # Ignore dsymutil warning (tool bug is actually linker)
     regsub -all "(^|\n)\[^\n\]*could not find object file symbol for symbol\[^\n\]*" $text "" text
 
+    # Ignore missing lto jobserver for tests that do more than 1 LTRANS unit
+    regsub -all "(^|\n)\[^\n\]*lto\[^\n\]*: warning: using serial compilation of \[^\n\]*" $text "" text
+    regsub -all "(^|\n)\[^\n\]*lto\[^\n\]*: note: see the \[^\n\]*'-flto' option documentation\[^\n\]* for more information" $text "" text
+
+    # Many tests that use visibility will still pass on platforms that don't support it.
+    regsub -all "(^|\n)\[^\n\]*lto1: warning: visibility attribute not supported in this configuration; ignored\[^\n\]*" $text "" text
+
     # If dg-enable-nn-line-numbers was provided, then obscure source-margin
     # line numbers by converting them to "NN" form.
     set text [maybe-handle-nn-line-numbers $text]
--- a/src/gcc/testsuite/lib/target-supports.exp
+++ b/src/gcc/testsuite/lib/target-supports.exp
@@ -5863,53 +5863,81 @@ proc check_effective_target_powerpc_p9modulo_ok { } {
 # return 1 if our compiler returns the ARCH_PWR defines with the options
 # as provided by the test.
 proc check_effective_target_has_arch_pwr5 { } {
-	return [check_no_compiler_messages arch_pwr5 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr5 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR5
 		#error does not have power5 support.
 		#else
 		/* "has power5 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr6 { } {
-	return [check_no_compiler_messages arch_pwr6 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr6 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR6
 		#error does not have power6 support.
 		#else
 		/* "has power6 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr7 { } {
-	return [check_no_compiler_messages arch_pwr7 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr7 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR7
 		#error does not have power7 support.
 		#else
 		/* "has power7 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr8 { } {
-	return [check_no_compiler_messages arch_pwr8 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr8 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR8
 		#error does not have power8 support.
 		#else
 		/* "has power8 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr9 { } {
-	return [check_no_compiler_messages arch_pwr9 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr9 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR9
 		#error does not have power9 support.
 		#else
 		/* "has power9 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
+}
+
+proc check_effective_target_has_arch_ppc64 { } {
+	return [check_no_compiler_messages_nocache arch_ppc64 assembly {
+		void test (void)
+		{
+		#ifndef _ARCH_PPC64
+		#error does not have ppc64 support.
+		#else
+		/* "has ppc64 support" */
+		#endif
+		}
+	} [current_compiler_flags]]
 }
 
 # Return 1 if this is a PowerPC target supporting -mcpu=power10.
@@ -5995,9 +6023,12 @@ proc check_effective_target_powerpc_float128_hw_ok { } {
 
 proc check_effective_target_ppc_float128 { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6005,9 +6036,12 @@ proc check_effective_target_ppc_float128 { } {
 
 proc check_effective_target_ppc_float128_insns { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128_HARDWARE__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6015,9 +6049,12 @@ proc check_effective_target_ppc_float128_insns { } {
 
 proc check_effective_target_powerpc_vsx { } {
     return [check_no_compiler_messages_nocache powerpc_vsx object {
+	void test (void)
+	{
 	#ifndef __VSX__
 	  nope no vsx
 	#endif
+	}
     }]
 }
 
--- a/src/gcc/tree-inline.c
+++ b/src/gcc/tree-inline.c
@@ -1979,11 +1979,10 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)
 	     || gimple_assign_rhs_code (ass) == VEC_COND_EXPR)
 	    && gimple_could_trap_p (ass))
 	  {
-	    gassign *cmp
-	      = gimple_build_assign (make_ssa_name (boolean_type_node),
-				     gimple_assign_rhs1 (ass));
+	    tree def = make_ssa_name (TREE_TYPE (gimple_assign_rhs1 (ass)));
+	    gassign *cmp = gimple_build_assign (def, gimple_assign_rhs1 (ass));
 	    gimple_seq_add_stmt (&stmts, cmp);
-	    gimple_assign_set_rhs1 (ass, gimple_assign_lhs (cmp));
+	    gimple_assign_set_rhs1 (ass, def);
 	  }
     }
 
--- a/src/gcc/tree-sra.c
+++ b/src/gcc/tree-sra.c
@@ -1647,7 +1647,18 @@ build_ref_for_offset (location_t loc, tree base, poly_int64 offset,
 static tree
 build_reconstructed_reference (location_t, tree base, struct access *model)
 {
-  tree expr = model->expr, prev_expr = NULL;
+  tree expr = model->expr;
+  /* We have to make sure to start just below the outermost union.  */
+  tree start_expr = expr;
+  while (handled_component_p (expr))
+    {
+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == UNION_TYPE)
+	start_expr = expr;
+      expr = TREE_OPERAND (expr, 0);
+    }
+
+  expr = start_expr;
+  tree prev_expr = NULL_TREE;
   while (!types_compatible_p (TREE_TYPE (expr), TREE_TYPE (base)))
     {
       if (!handled_component_p (expr))
--- a/src/gcc/tree-ssa-sccvn.c
+++ b/src/gcc/tree-ssa-sccvn.c
@@ -3136,12 +3136,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       poly_int64 extra_off = 0;
       if (j == 0 && i >= 0
 	  && lhs_ops[0].opcode == MEM_REF
-	  && maybe_ne (lhs_ops[0].off, -1))
+	  && known_ne (lhs_ops[0].off, -1))
 	{
 	  if (known_eq (lhs_ops[0].off, vr->operands[i].off))
 	    i--, j--;
 	  else if (vr->operands[i].opcode == MEM_REF
-		   && maybe_ne (vr->operands[i].off, -1))
+		   && known_ne (vr->operands[i].off, -1))
 	    {
 	      extra_off = vr->operands[i].off - lhs_ops[0].off;
 	      i--, j--;
@@ -3168,6 +3168,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       copy_reference_ops_from_ref (rhs1, &rhs);
 
       /* Apply an extra offset to the inner MEM_REF of the RHS.  */
+      bool force_no_tbaa = false;
       if (maybe_ne (extra_off, 0))
 	{
 	  if (rhs.length () < 2)
@@ -3180,6 +3181,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
 	  rhs[ix].op0 = int_const_binop (PLUS_EXPR, rhs[ix].op0,
 					 build_int_cst (TREE_TYPE (rhs[ix].op0),
 							extra_off));
+	  /* When we have offsetted the RHS, reading only parts of it,
+	     we can no longer use the original TBAA type, force alias-set
+	     zero.  */
+	  force_no_tbaa = true;
 	}
 
       /* Save the operands since we need to use the original ones for
@@ -3232,8 +3237,11 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       /* Adjust *ref from the new operands.  */
       ao_ref rhs1_ref;
       ao_ref_init (&rhs1_ref, rhs1);
-      if (!ao_ref_init_from_vn_reference (&r, ao_ref_alias_set (&rhs1_ref),
-					  ao_ref_base_alias_set (&rhs1_ref),
+      if (!ao_ref_init_from_vn_reference (&r,
+					  force_no_tbaa ? 0
+					  : ao_ref_alias_set (&rhs1_ref),
+					  force_no_tbaa ? 0
+					  : ao_ref_base_alias_set (&rhs1_ref),
 					  vr->type, vr->operands))
 	return (void *)-1;
       /* This can happen with bitfields.  */
@@ -4758,7 +4766,7 @@ valueized_wider_op (tree wide_type, tree op, bool allow_truncate)
 
   /* For constants simply extend it.  */
   if (TREE_CODE (op) == INTEGER_CST)
-    return wide_int_to_tree (wide_type, wi::to_wide (op));
+    return wide_int_to_tree (wide_type, wi::to_widest (op));
 
   return NULL_TREE;
 }
--- a/src/libcpp/ChangeLog
+++ b/src/libcpp/ChangeLog
@@ -1,3 +1,13 @@
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* directives.c (destringize_and_run): Override the location of
+	the CPP_PRAGMA token from a _Pragma directive to the location of
+	the expansion point, as is done for the tokens lexed from it.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/libcpp/directives.c
+++ b/src/libcpp/directives.c
@@ -1887,6 +1887,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in,
       maxcount = 50;
       toks = XNEWVEC (cpp_token, maxcount);
       toks[0] = pfile->directive_result;
+      toks[0].src_loc = expansion_loc;
 
       do
 	{
--- a/src/libgcc/config/avr/libf7/ChangeLog
+++ b/src/libgcc/config/avr/libf7/ChangeLog
@@ -1,3 +1,12 @@
+2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backported from master:
+	2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/99184
+	* libf7-asm.sx (to_integer, to_unsigned): Don't round 16-bit
+	and 32-bit integers.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/libgcc/config/avr/libf7/libf7-asm.sx
+++ b/src/libgcc/config/avr/libf7/libf7-asm.sx
@@ -601,9 +601,6 @@ DEFUN to_integer
     tst     C6
     brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
 
-    rcall   .Lround
-    brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
-
     brtc 9f                 ;   >= 0         =>  return
     sbrc    Mask,   5
     .global __negdi2
@@ -658,30 +655,6 @@ DEFUN to_integer
     .global __clr_8
     XJMP    __clr_8
 
-.Lround:
-    ;; C6.7 is known to be 0 here.
-    ;; Return N = 1 iff we have to saturate.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    cln
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    ret
 ENDF to_integer
 #endif /* F7MOD_to_integer_ */
 
@@ -725,29 +698,6 @@ DEFUN to_unsigned
     clr     CA
     F7call  lshrdi3
     POP     r16
-
-    ;; Rounding
-    ;; ??? C6.7 is known to be 0 here.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    brcs    .Lset_0xffff    ; Rounding overflow  =>  saturate
     ret
 
 .Lset_0xffff:
--- a/src/libgo/sysinfo.c
+++ b/src/libgo/sysinfo.c
@@ -150,9 +150,6 @@
 #if defined(HAVE_LINUX_ETHER_H)
 #include <linux/ether.h>
 #endif
-#if defined(HAVE_LINUX_FS_H)
-#include <linux/fs.h>
-#endif
 #if defined(HAVE_LINUX_REBOOT_H)
 #include <linux/reboot.h>
 #endif
--- a/src/libphobos/ChangeLog
+++ b/src/libphobos/ChangeLog
@@ -1,3 +1,8 @@
+2022-12-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* src/std/path.d (expandTilde): Handle more errno codes that could be
+	left set by getpwnam_r.
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/libphobos/src/std/path.d
+++ b/src/libphobos/src/std/path.d
@@ -3850,7 +3850,7 @@ string expandTilde(string inputPath) nothrow
     version (Posix)
     {
         import core.exception : onOutOfMemoryError;
-        import core.stdc.errno : errno, ERANGE;
+        import core.stdc.errno : errno, EBADF, ENOENT, EPERM, ERANGE, ESRCH;
         import core.stdc.stdlib : malloc, free, realloc;
 
         /*  Joins a path from a C string to the remainder of path.
@@ -3950,7 +3950,7 @@ string expandTilde(string inputPath) nothrow
                 scope(exit) free(extra_memory);
 
                 passwd result;
-                while (1)
+                loop: while (1)
                 {
                     extra_memory = cast(char*) realloc(extra_memory, extra_memory_size * char.sizeof);
                     if (extra_memory == null)
@@ -3969,10 +3969,23 @@ string expandTilde(string inputPath) nothrow
                         break;
                     }
 
-                    if (errno != ERANGE &&
+                    switch (errno)
+                    {
+                        case ERANGE:
                         // On BSD and OSX, errno can be left at 0 instead of set to ERANGE
-                        errno != 0)
-                        onOutOfMemoryError();
+                        case 0:
+                            break;
+
+                        case ENOENT:
+                        case ESRCH:
+                        case EBADF:
+                        case EPERM:
+                            // The given name or uid was not found.
+                            break loop;
+
+                        default:
+                            onOutOfMemoryError();
+                    }
 
                     // extra_memory isn't large enough
                     import core.checkedint : mulu;
--- a/src/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/src/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -72,7 +72,9 @@
 #include <sys/vt.h>
 #include <linux/cdrom.h>
 #include <linux/fd.h>
+#if SANITIZER_ANDROID
 #include <linux/fs.h>
+#endif
 #include <linux/hdreg.h>
 #include <linux/input.h>
 #include <linux/ioctl.h>
@@ -822,10 +824,10 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);
   unsigned IOCTL_EVIOCGPROP = IOCTL_NOT_PRESENT;
   unsigned IOCTL_EVIOCSKEYCODE_V2 = IOCTL_NOT_PRESENT;
 #endif
-  unsigned IOCTL_FS_IOC_GETFLAGS = FS_IOC_GETFLAGS;
-  unsigned IOCTL_FS_IOC_GETVERSION = FS_IOC_GETVERSION;
-  unsigned IOCTL_FS_IOC_SETFLAGS = FS_IOC_SETFLAGS;
-  unsigned IOCTL_FS_IOC_SETVERSION = FS_IOC_SETVERSION;
+  unsigned IOCTL_FS_IOC_GETFLAGS = _IOR('f', 1, long);
+  unsigned IOCTL_FS_IOC_GETVERSION = _IOR('v', 1, long);
+  unsigned IOCTL_FS_IOC_SETFLAGS = _IOW('f', 2, long);
+  unsigned IOCTL_FS_IOC_SETVERSION = _IOW('v', 2, long);
   unsigned IOCTL_GIO_CMAP = GIO_CMAP;
   unsigned IOCTL_GIO_FONT = GIO_FONT;
   unsigned IOCTL_GIO_UNIMAP = GIO_UNIMAP;
--- a/src/libstdc++-v3/ChangeLog
+++ b/src/libstdc++-v3/ChangeLog
@@ -1,3 +1,95 @@
+2022-11-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/authors.xml: Remove empty author element.
+	* doc/xml/manual/spine.xml: Likewise.
+	* doc/html/*: Regenerate.
+
+2022-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/98421
+	* include/std/span (span(Iter, size_type), span(Iter, Iter)):
+	Add valid range checks.
+	* testsuite/23_containers/span/cons_1_assert_neg.cc: New test.
+	* testsuite/23_containers/span/cons_2_assert_neg.cc: New test.
+
+2022-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/list.tcc (list::merge) [!USE_CXX11_ABI]: Remove
+	call to size() and try-catch block.
+
+2022-08-03  Tim Adye  <Tim.Adye@cern.ch>
+
+	Backported from master:
+	2021-06-04  Tim Adye  <Tim.Adye@cern.ch>
+
+	* include/std/any (any::_Manager::_S_access): New static
+	function to access the contained value.
+	(any::emplace, __any_caster): Use _S_access member of the
+	manager type.
+
+2022-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ranges (subrange(i, s, n)): Remove assertion.
+	* testsuite/std/ranges/subrange/constexpr.cc: New test.
+
+2022-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100748
+	PR libstdc++/103133
+	* config/os/gnu-linux/os_defines.h (_GLIBCXX_GTHREAD_USE_WEAK):
+	Define for glibc 2.34 and later.
+
+2022-07-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106162
+	* include/Makefile.am (largefile-config.h): Add
+	stamp-${host_alias} prerequisite.
+	* include/Makefile.in: Regenerate.
+
+2022-07-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/range_access.h (begin(valarray), end(valarray)):
+	Add noexcept.
+
+2022-07-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-07-22  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/106320
+	* include/std/ranges (single_view): Relax constraints on
+	default constructor so as to preserve pre-P2325R3 behavior.
+	(filter_view): Likewise.
+	(transform_view): Likewise.
+	(take_while_view): Likewise.
+	(drop_while_view): Likewise.
+	* testsuite/std/ranges/adaptors/join.cc (test13): New test.
+	* testsuite/std/ranges/p2325.cc: Fix S to be only non default
+	constructible and not also non copy constructible.  XFAIL the
+	tests that verify a non default constructible functor makes a
+	view non default constructible (lines 94, 97 and 98).  XFAIL
+	the test that effectively verifies a non default constructible
+	element type makes single_view non default constructible (line
+	114).
+
 2022-06-28  Release Manager
 
 	* GCC 10.4.0 released.
--- a/src/libstdc++-v3/config/os/gnu-linux/os_defines.h
+++ b/src/libstdc++-v3/config/os/gnu-linux/os_defines.h
@@ -61,4 +61,10 @@
   (__gthread_active_p() ? __gthread_self() : (__gthread_t)1)
 #endif
 
+#if __GLIBC_PREREQ(2, 34)
+// Since glibc 2.34 all pthreads functions are usable without linking to
+// libpthread.
+# define _GLIBCXX_GTHREAD_USE_WEAK 0
+#endif
+
 #endif
--- a/src/libstdc++-v3/doc/html/bk02.html
+++ b/src/libstdc++-v3/doc/html/bk02.html
@@ -1,2 +1,2 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library" /><link rel="prev" href="manual/backwards.html" title="Backwards Compatibility" /><link rel="next" href="api.html" title="The GNU C++ Library API Reference" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="manual/backwards.html">Prev</a></td><th width="60%" align="center"></th><td width="20%" align="right"><a accesskey="n" href="api.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="article"><a href="api.html">The GNU C++ Library API Reference</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="manual/backwards.html">Prev</a></td><td width="20%" align="center"></td><td width="40%" align="right"><a accesskey="n" href="api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Backwards Compatibility</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">The GNU C++ Library API Reference</td></tr></table></div></body></html>
\ No newline at end of file
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library" /><link rel="prev" href="manual/appendix_gfdl.html" title="AppendixE.GNU Free Documentation License" /><link rel="next" href="api.html" title="The GNU C++ Library API Reference" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="manual/appendix_gfdl.html">Prev</a></td><th width="60%" align="center"></th><td width="20%" align="right"><a accesskey="n" href="api.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="article"><a href="api.html">The GNU C++ Library API Reference</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="manual/appendix_gfdl.html">Prev</a></td><td width="20%" align="center"></td><td width="40%" align="right"><a accesskey="n" href="api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">AppendixE.GNU Free Documentation License</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">The GNU C++ Library API Reference</td></tr></table></div></body></html>
\ No newline at end of file
--- a/src/libstdc++-v3/doc/html/manual/extensions.html
+++ b/src/libstdc++-v3/doc/html/manual/extensions.html
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>PartIII. Extensions</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library Manual" /><link rel="prev" href="io_and_c.html" title="Interacting with C" /><link rel="next" href="ext_preface.html" title="" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">PartIII.
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>PartIII. Extensions</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library Manual" /><link rel="prev" href="concurrency.html" title="Chapter15. Concurrency" /><link rel="next" href="ext_preface.html" title="" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">PartIII.
   Extensions
   
-</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="io_and_c.html">Prev</a></td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"><a accesskey="n" href="ext_preface.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.ext"></a>PartIII.
+</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="concurrency.html">Prev</a></td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"><a accesskey="n" href="ext_preface.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.ext"></a>PartIII.
   Extensions
   <a id="id-1.3.5.1.1.1" class="indexterm"></a>
 </h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="preface"><a href="ext_preface.html"></a></span></dt><dt><span class="chapter"><a href="ext_compile_checks.html">16. Compile Time Checks</a></span></dt><dt><span class="chapter"><a href="debug_mode.html">17. Debug Mode</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode.html#manual.ext.debug_mode.intro">Intro</a></span></dt><dt><span class="section"><a href="debug_mode_semantics.html">Semantics</a></span></dt><dt><span class="section"><a href="debug_mode_using.html">Using</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_using.html#debug_mode.using.mode">Using the Debug Mode</a></span></dt><dt><span class="section"><a href="debug_mode_using.html#debug_mode.using.specific">Using a Specific Debug Container</a></span></dt></dl></dd><dt><span class="section"><a href="debug_mode_design.html">Design</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.goals">Goals</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods">Methods</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.wrappers">The Wrapper Model</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.safe_iter">Safe Iterators</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.safe_seq">Safe Sequences (Containers)</a></span></dt></dl></dd><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.precond">Precondition Checking</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.coexistence">Release- and debug-mode coexistence</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#methods.coexistence.compile">Compile-time coexistence of release- and debug-mode components</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#methods.coexistence.link">Link- and run-time coexistence of release- and
@@ -68,4 +68,7 @@
 	  Text <code class="function">modify</code> Up
 	</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#performance.priority_queue.text_modify_down">
 	  Text <code class="function">modify</code> Down
-	</a></span></dt></dl></dd><dt><span class="section"><a href="policy_based_data_structures_test.html#pbds.test.performance.observations">Observations</a></span></dt><dd><dl><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.associative">Associative</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.priority_queue">Priority_Queue</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="policy_data_structures_ack.html">Acknowledgments</a></span></dt><dt><span class="bibliography"><a href="policy_data_structures.html#pbds.biblio">Bibliography</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_containers.html">22. HP/SGI Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="ext_containers.html#manual.ext.containers.sgi">Backwards Compatibility</a></span></dt><dt><span class="section"><a href="ext_sgi.html">Deprecated</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_utilities.html">23. Utilities</a></span></dt><dt><span class="chapter"><a href="ext_algorithms.html">24. Algorithms</a></span></dt><dt><span class="chapter"><a href="ext_numerics.html">25. Numerics</a></span></dt><dt><span class="chapter"><a href="ext_iterators.html">26. Iterators</a></span></dt><dt><span class="chapter"><a href="ext_io.html">27. Input and Output</a></span></dt><dd><dl><dt><span class="section"><a href="ext_io.html#manual.ext.io.filebuf_derived">Derived filebufs</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_demangling.html">28. Demangling</a></span></dt><dt><span class="chapter"><a href="ext_concurrency.html">29. Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.threads">Interface to Locks and Mutexes</a></span></dt><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.atomics">Interface to Atomic Functions</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_impl.html">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.atomic_fallbacks">Using Built-in Atomic Functions</a></span></dt><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.thread">Thread Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_use.html">Use</a></span></dt></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="io_and_c.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="ext_preface.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Interacting with C</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"></td></tr></table></div></body></html>
\ No newline at end of file
+	</a></span></dt></dl></dd><dt><span class="section"><a href="policy_based_data_structures_test.html#pbds.test.performance.observations">Observations</a></span></dt><dd><dl><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.associative">Associative</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.priority_queue">Priority_Queue</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="policy_data_structures_ack.html">Acknowledgments</a></span></dt><dt><span class="bibliography"><a href="policy_data_structures.html#pbds.biblio">Bibliography</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_containers.html">22. HP/SGI Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="ext_containers.html#manual.ext.containers.sgi">Backwards Compatibility</a></span></dt><dt><span class="section"><a href="ext_sgi.html">Deprecated</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_utilities.html">23. Utilities</a></span></dt><dt><span class="chapter"><a href="ext_algorithms.html">24. Algorithms</a></span></dt><dt><span class="chapter"><a href="ext_numerics.html">25. Numerics</a></span></dt><dt><span class="chapter"><a href="ext_iterators.html">26. Iterators</a></span></dt><dt><span class="chapter"><a href="ext_io.html">27. Input and Output</a></span></dt><dd><dl><dt><span class="section"><a href="ext_io.html#manual.ext.io.filebuf_derived">Derived filebufs</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_demangling.html">28. Demangling</a></span></dt><dt><span class="chapter"><a href="ext_concurrency.html">29. Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.threads">Interface to Locks and Mutexes</a></span></dt><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.atomics">Interface to Atomic Functions</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_impl.html">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.atomic_fallbacks">Using Built-in Atomic Functions</a></span></dt><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.thread">Thread Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_use.html">Use</a></span></dt></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="concurrency.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="ext_preface.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter15.
+  Concurrency
+  
+</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"></td></tr></table></div></body></html>
\ No newline at end of file
--- a/src/libstdc++-v3/doc/html/manual/index.html
+++ b/src/libstdc++-v3/doc/html/manual/index.html
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="PartI. Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a></td><th width="60%" align="center"></th><td width="20%" align="right"><a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname"></span> <span class="surname"></span></h3></div><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright  2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="PartI. Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a></td><th width="60%" align="center"></th><td width="20%" align="right"><a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright  2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
       <a class="link" href="https://www.fsf.org" target="_top">FSF</a>
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
--- a/src/libstdc++-v3/doc/xml/authors.xml
+++ b/src/libstdc++-v3/doc/xml/authors.xml
@@ -13,18 +13,13 @@
       </address>
     </affiliation>
 
-    <authorblurb>
+    <personblurb>
       <para>
       </para>
-    </authorblurb>
+    </personblurb>
   </author>
 -->
 
-  <author><personname><firstname/><surname/></personname><personblurb>
-      <para>
-      </para>
-    </personblurb></author>
-
   <author><personname><firstname>Paolo</firstname><surname>Carlini</surname></personname><personblurb>
       <para>
 	TR1, LWG Active, Closed, Defects lists.
--- a/src/libstdc++-v3/doc/xml/manual/spine.xml
+++ b/src/libstdc++-v3/doc/xml/manual/spine.xml
@@ -48,18 +48,13 @@
       </address>
     </affiliation>
 
-    <authorblurb>
+    <personblurb>
       <para>
       </para>
-    </authorblurb>
+    </personblurb>
   </author>
 -->
 
-  <author><personname><firstname/><surname/></personname><personblurb>
-      <para>
-      </para>
-    </personblurb></author>
-
   <author><personname><firstname>Paolo</firstname><surname>Carlini</surname></personname><personblurb>
       <para>
 	TR1, LWG Active, Closed, Defects lists.
--- a/src/libstdc++-v3/include/Makefile.am
+++ b/src/libstdc++-v3/include/Makefile.am
@@ -1248,7 +1248,7 @@ stamp-float128:
 endif
 
 # This header is not installed, it's only used to build libstdc++ itself.
-${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER} stamp-${host_alias}
 	@rm -f $@.tmp
 	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
 	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
--- a/src/libstdc++-v3/include/Makefile.in
+++ b/src/libstdc++-v3/include/Makefile.in
@@ -1729,7 +1729,7 @@ stamp-host: ${host_headers} ${bits_host_headers} ${ext_host_headers} ${host_head
 @ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
 
 # This header is not installed, it's only used to build libstdc++ itself.
-${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER} stamp-${host_alias}
 	@rm -f $@.tmp
 	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
 	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
--- a/src/libstdc++-v3/include/bits/list.tcc
+++ b/src/libstdc++-v3/include/bits/list.tcc
@@ -406,8 +406,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  iterator __last1 = end();
 	  iterator __first2 = __x.begin();
 	  iterator __last2 = __x.end();
+#if _GLIBCXX_USE_CXX11_ABI
 	  const size_t __orig_size = __x.size();
 	  __try {
+#endif
 	    while (__first1 != __last1 && __first2 != __last2)
 	      if (*__first2 < *__first1)
 		{
@@ -422,6 +424,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
 	    this->_M_inc_size(__x._M_get_size());
 	    __x._M_set_size(0);
+#if _GLIBCXX_USE_CXX11_ABI
 	  }
 	  __catch(...)
 	    {
@@ -430,6 +433,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	      __x._M_set_size(__dist);
 	      __throw_exception_again;
 	    }
+#endif
 	}
     }
 
--- a/src/libstdc++-v3/include/bits/range_access.h
+++ b/src/libstdc++-v3/include/bits/range_access.h
@@ -104,10 +104,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Tp> class valarray;
   // These overloads must be declared for cbegin and cend to use them.
-  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
-  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
-  template<typename _Tp> _Tp* end(valarray<_Tp>&);
-  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);
+  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
+  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
+  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
+  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;
 
   /**
    *  @brief  Return an iterator pointing to the first element of
--- a/src/libstdc++-v3/include/std/any
+++ b/src/libstdc++-v3/include/std/any
@@ -263,9 +263,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       {
 	using _VTp = decay_t<_Tp>;
 	__do_emplace<_VTp>(std::forward<_Args>(__args)...);
-	any::_Arg __arg;
-	this->_M_manager(any::_Op_access, this, &__arg);
-	return *static_cast<_VTp*>(__arg._M_obj);
+	return *any::_Manager<_VTp>::_S_access(_M_storage);
       }
 
     /// Emplace with an object created from @p __il and @p __args as
@@ -276,9 +274,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       {
 	using _VTp = decay_t<_Tp>;
 	__do_emplace<_VTp, _Up>(__il, std::forward<_Args>(__args)...);
-	any::_Arg __arg;
-	this->_M_manager(any::_Op_access, this, &__arg);
-	return *static_cast<_VTp*>(__arg._M_obj);
+	return *any::_Manager<_VTp>::_S_access(_M_storage);
       }
 
     // modifiers
@@ -384,6 +380,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    void* __addr = &__storage._M_buffer;
 	    ::new (__addr) _Tp(std::forward<_Args>(__args)...);
 	  }
+
+	static _Tp*
+	_S_access(const _Storage& __storage)
+	{
+	  // The contained object is in __storage._M_buffer
+	  const void* __addr = &__storage._M_buffer;
+	  return static_cast<_Tp*>(const_cast<void*>(__addr));
+	}
       };
 
     // Manage external contained object.
@@ -405,6 +409,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  {
 	    __storage._M_ptr = new _Tp(std::forward<_Args>(__args)...);
 	  }
+	static _Tp*
+	_S_access(const _Storage& __storage)
+	{
+	  // The contained object is in *__storage._M_ptr
+	  return static_cast<_Tp*>(__storage._M_ptr);
+	}
       };
   };
 
@@ -516,9 +526,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
 	  )
 	{
-	  any::_Arg __arg;
-	  __any->_M_manager(any::_Op_access, __any, &__arg);
-	  return __arg._M_obj;
+	  return any::_Manager<_Up>::_S_access(__any->_M_storage);
 	}
       return nullptr;
     }
--- a/src/libstdc++-v3/include/std/ranges
+++ b/src/libstdc++-v3/include/std/ranges
@@ -264,8 +264,6 @@ namespace ranges
 	requires (_Kind == subrange_kind::sized)
       : _M_begin(std::move(__i)), _M_end(__s)
       {
-	using __detail::__to_unsigned_like;
-	__glibcxx_assert(__n == __to_unsigned_like(ranges::distance(__i, __s)));
 	if constexpr (_S_store_size)
 	  _M_size._M_size = __n;
       }
@@ -518,7 +516,7 @@ namespace ranges
     class single_view : public view_interface<single_view<_Tp>>
     {
     public:
-      single_view() requires default_initializable<_Tp> = default;
+      single_view() = default;
 
       constexpr explicit
       single_view(const _Tp& __t)
@@ -1592,9 +1590,7 @@ namespace views
       [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;
 
     public:
-      filter_view() requires (default_initializable<_Vp>
-			      && default_initializable<_Pred>)
-	= default;
+      filter_view() requires default_initializable<_Vp> = default;
 
       constexpr
       filter_view(_Vp __base, _Pred __pred)
@@ -1940,9 +1936,7 @@ namespace views
       __detail::__box<_Fp> _M_fun;
 
     public:
-      transform_view() requires (default_initializable<_Vp>
-				 && default_initializable<_Fp>)
-	= default;
+      transform_view() requires default_initializable<_Vp> = default;
 
       constexpr
       transform_view(_Vp __base, _Fp __fun)
@@ -2220,9 +2214,7 @@ namespace views
       __detail::__box<_Pred> _M_pred;
 
     public:
-      take_while_view() requires (default_initializable<_Vp>
-				  && default_initializable<_Pred>)
-	= default;
+      take_while_view() requires default_initializable<_Vp> = default;
 
       constexpr
       take_while_view(_Vp base, _Pred __pred)
@@ -2389,9 +2381,7 @@ namespace views
       [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;
 
     public:
-      drop_while_view() requires (default_initializable<_Vp>
-				  && default_initializable<_Pred>)
-	= default;
+      drop_while_view() requires default_initializable<_Vp> = default;
 
       constexpr
       drop_while_view(_Vp __base, _Pred __pred)
--- a/src/libstdc++-v3/include/std/span
+++ b/src/libstdc++-v3/include/std/span
@@ -165,6 +165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    {
 	      __glibcxx_assert(__count == _Extent);
 	    }
+	  __glibcxx_requires_valid_range(__first, __first + __count);
 	}
 
       template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
@@ -180,6 +181,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    {
 	      __glibcxx_assert((__last - __first) == _Extent);
 	    }
+	  __glibcxx_requires_valid_range(__first, __last);
 	}
 
       template<size_t _ArrayExtent>
new file mode 100644
--- /dev/null
+++ b/src/libstdc++-v3/testsuite/23_containers/span/cons_1_assert_neg.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { xfail *-*-* } }
+// { dg-require-effective-target c++2a }
+
+#undef _GLIBCXX_DEBUG
+#define _GLIBCXX_DEBUG
+#include <span>
+#include <vector>
+
+int main()
+{
+  std::vector<int> v(2);
+  std::span<int, std::dynamic_extent> s(v.begin(), 3);
+}
new file mode 100644
--- /dev/null
+++ b/src/libstdc++-v3/testsuite/23_containers/span/cons_2_assert_neg.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++2a" }
+// { dg-do run { xfail *-*-* } }
+// { dg-require-effective-target c++2a }
+
+#undef _GLIBCXX_DEBUG
+#define _GLIBCXX_DEBUG
+#include <span>
+#include <vector>
+
+int main()
+{
+  std::vector<int> v(2), w(1);
+  std::span<int, std::dynamic_extent> s(v.begin(), w.end());
+}
--- a/src/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
+++ b/src/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
@@ -159,6 +159,21 @@ test10()
   VERIFY( ranges::next(v.begin()) == v.end() );
 }
 
+
+void
+test13()
+{
+  // PR libstdc++/106320
+  auto l = std::views::transform([](auto x) {
+    return x | std::views::transform([x=0](auto y) {
+      return y;
+    });
+  });
+  static_assert(!std::default_initializable<decltype(l)>);
+  std::vector<std::vector<int>> v{{5, 6, 7}};
+  v | l | std::views::join;
+}
+
 int
 main()
 {
@@ -171,4 +186,5 @@ main()
   test07();
   test08();
   test10();
+  test13();
 }
--- a/src/libstdc++-v3/testsuite/std/ranges/p2325.cc
+++ b/src/libstdc++-v3/testsuite/std/ranges/p2325.cc
@@ -5,8 +5,8 @@
 // Parts of P2325R3 are deliberately omitted in libstdc++ 10, in particular the
 // removal of default ctors for back_/front_insert_iterator, ostream_iterator,
 // ref_view and basic_istream_view/::iterator, so as to maximize backward
-// compatibility with pre-P2325R3 code.  So most static_asserts in this test fail,
-// see the xfails at the end of this file.
+// compatibility with pre-P2325R3 code.  Namely all asserts that verify lack of
+// default constructibility fail; see the xfails at the end of this file.
 
 #include <ranges>
 #include <iterator>
@@ -93,7 +93,7 @@ test06()
   static_assert(default_initializable<decltype(views::single(0) | adaptor(f1))>);
   static_assert(!default_initializable<decltype(views::single(0) | adaptor(f2))>);
 
-  struct S { S() = delete; };
+  struct S { S() = delete; S(const S&) = default; S(S&&) = default; };
   static_assert(!default_initializable<decltype(views::single(declval<S>()) | adaptor(f1))>);
   static_assert(!default_initializable<decltype(views::single(declval<S>()) | adaptor(f2))>);
 }
@@ -109,7 +109,7 @@ void
 test07()
 {
   // Verify join_view is conditionally default constructible.
-  struct S { S() = delete; };
+  struct S { S() = delete; S(const S&) = default; S(S&&) = default; };
   using type1 = ranges::join_view<ranges::single_view<ranges::single_view<S>>>;
   static_assert(!default_initializable<type1>);
   using type2 = ranges::join_view<ranges::single_view<ranges::single_view<int>>>;
@@ -173,6 +173,10 @@ test11()
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 76 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 77 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 84 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 94 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 97 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 98 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 114 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 124 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 126 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 128 }
new file mode 100644
--- /dev/null
+++ b/src/libstdc++-v3/testsuite/std/ranges/subrange/constexpr.cc
@@ -0,0 +1,26 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+#include <ranges>
+
+struct iterator
+{
+  using difference_type = int;
+
+  int i;
+
+  int operator*() const { return i; }
+
+  // These are intentionally not constexpr:
+  iterator& operator++() { ++i; return *this; }
+  iterator operator++(int) { return {i++}; }
+  bool operator==(const iterator& it) const { return i == it.i; }
+};
+
+constexpr iterator begin(1), end(2);
+
+using std::ranges::subrange;
+using std::ranges::subrange_kind;
+
+// This used to fail due to using operator++ and operator== in an assertion:
+constexpr subrange<iterator, iterator, subrange_kind::sized> s(begin, end, 1);
